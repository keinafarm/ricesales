承知いたしました。UXが改善され、より良いシステムになりましたね。

今回のコード変更を、システムの正式な仕様として聖典ファイルに反映させるため、`32_購入者向け機能 実装手順書.md` を更新します。

主な変更点は以下の通りです。

1. **「目的」セクションの更新:**
    * 今回のUX改善（注文内容確認ページへ進む前の在庫事前チェック）を、この手順書が実現する仕様の一つとして明記します。

2. **`orders/views.py` のコード差し替え:**
    * バックエンド実装のセクションにある `orders/views.py` のソースコードを、先ほど修正が完了した最終版のコードに差し替えます。特に、`order_confirm` ビューに在庫の事前チェック処理が追加された点を差分コメントで明記します。

以下に、更新後の `32_購入者向け機能 実装手順書.md` の全内容を提示します。

---

### **【機能単位】購入者向け機能 実装手順書 (Ver. 3.2)**

#### 1. 目的

この手順書は、`31_商品・在庫・品種マスタ管理機能 実装手順書`までが完了した状態から、購入者が利用する主要な機能を、新しい在庫管理モデルに対応させるための公式ドキュメントです。

この手順書を適用することで、以下の仕様が実現されます。

* **在庫の可視化:**
  * サイドバーに、品種ごとの具体的な残り在庫量（kg）と、自身のカート内消費量（玄米換算）が表示される。
  * 商品一覧の各商品カードに、購入可能な残り個数が表示される。
* **リアルタイム在庫チェック:**
  * 商品一覧画面でカートに商品を追加・変更する際に、リアルタイムで在庫量を確認し、在庫を超える追加ができないように制御する。
* **安全な注文確定:**
  * 注文確定処理時に、データベースのトランザクションと排他ロックを用いて在庫を安全に引き当て、複数ユーザーの同時注文による売り越しを防止する。
* **注文確定前の在庫チェック:**
  * 注文内容確認画面へ遷移する前に在庫を事前チェックし、不足している場合はエラーメッセージと共に商品一覧へリダイレクトさせることで、不快なユーザー体験を防ぐ。

#### 2. 手順1：カート機能のバックエンド実装 (`cart`アプリケーション)

##### **ファイル:** `cart/cart.py` **(全面的に上書き)**

```python
# cart/cart.py
from decimal import Decimal
from django.conf import settings
from products.models import Product, Stock
from accounts.models import Destination

class Cart:
    def __init__(self, request):
        self.session = request.session
        cart = self.session.get(settings.CART_SESSION_ID)
        if not cart:
            cart = self.session[settings.CART_SESSION_ID] = {}
        self.cart = cart
        self.destinations_cache = {}
        self.products_cache = {}

    def add(self, product, destination, quantity=1, override_quantity=False):
        product_id = str(product.id)
        destination_id = str(destination.id)

        if destination_id not in self.cart:
            self.cart[destination_id] = {'items': {}}
        
        if product_id not in self.cart[destination_id]['items']:
            self.cart[destination_id]['items'][product_id] = {'quantity': 0, 'price': str(product.price)}

        if override_quantity:
            self.cart[destination_id]['items'][product_id]['quantity'] = quantity
        else:
            self.cart[destination_id]['items'][product_id]['quantity'] += quantity
        self.save()

    def update(self, product, destination, quantity):
        """指定された数量でカート内の商品を更新する。数量が0以下の場合は削除する。"""
        product_id = str(product.id)
        destination_id = str(destination.id)
        
        if quantity > 0:
            if destination_id not in self.cart:
                self.cart[destination_id] = {'items': {}}
            
            if product_id not in self.cart[destination_id]['items']:
                 self.cart[destination_id]['items'][product_id] = {'quantity': quantity, 'price': str(product.price)}
            else:
                self.cart[destination_id]['items'][product_id]['quantity'] = quantity
        else:
            self.remove(product, destination)
        
        self.save()

    def remove(self, product, destination):
        product_id = str(product.id)
        destination_id = str(destination.id)

        if destination_id in self.cart and product_id in self.cart[destination_id]['items']:
            del self.cart[destination_id]['items'][product_id]
            if not self.cart[destination_id]['items']:
                del self.cart[destination_id]
            self.save()

    def __iter__(self):
        all_destination_ids = list(self.cart.keys())
        all_product_ids = [pid for d in self.cart.values() for pid in d.get('items', {}).keys()]

        self.destinations_cache = {str(d.id): d for d in Destination.objects.filter(id__in=all_destination_ids)}
        self.products_cache = {str(p.id): p for p in Product.objects.filter(id__in=all_product_ids)}
        
        for dest_id, dest_data in sorted(self.cart.items(), key=lambda item: self.destinations_cache.get(item).name if self.destinations_cache.get(item) else ''):
            destination_obj = self.destinations_cache.get(dest_id)
            if not destination_obj: continue

            items_list = []
            items_subtotal = Decimal('0.0')
            for prod_id, item_data in dest_data['items'].items():
                product_obj = self.products_cache.get(prod_id)
                if not product_obj: continue
                
                price = Decimal(item_data['price'])
                quantity = item_data['quantity']
                total_price = price * quantity
                items_subtotal += total_price

                items_list.append({
                    'product': product_obj,
                    'quantity': quantity,
                    'price': int(price),
                    'total_price': int(total_price),
                })
            
            shipping_fee = self.get_shipping_fee(destination_obj)
            group_total_price = items_subtotal + shipping_fee

            yield {
                'destination': destination_obj,
                'items': items_list,
                'items_subtotal': int(items_subtotal),
                'shipping_fee': int(shipping_fee),
                'group_total_price': int(group_total_price),
            }

    def get_shipping_fee(self, destination):
        if destination.delivery_method == Destination.DeliveryMethod.TEWATASHI:
            return Decimal('0')
        elif destination.shipping_zone == Destination.ShippingZone.ENCHI:
            return Decimal(settings.REMOTE_SHIPPING_FEE)
        else:
            return Decimal(settings.NORMAL_SHIPPING_FEE)

    def get_grand_total_price(self):
        return int(sum(group['group_total_price'] for group in self))
    
    def get_item_quantity(self, product_id, destination_id):
        dest_cart = self.cart.get(str(destination_id), {})
        item = dest_cart.get('items', {}).get(str(product_id))
        return item['quantity'] if item else 0

    def __len__(self):
        return sum(item['quantity'] for dest_data in self.cart.values() for item in dest_data.get('items', {}).values())

    def save(self):
        self.session.modified = True

    def clear(self):
        if settings.CART_SESSION_ID in self.session:
            del self.session[settings.CART_SESSION_ID]
            self.save()
```

##### **ファイル:** `cart/urls.py` **(全面的に上書き)**

```python
# cart/urls.py
from django.urls import path
from . import views

app_name = 'cart'

urlpatterns = [
    path('update/', views.update_cart, name='update_cart'),
    path('remove/', views.remove_from_cart, name='remove_from_cart'),
]
```

##### **ファイル:** `cart/views.py` **(全面的に上書き)**

```python
# cart/views.py
from django.shortcuts import get_object_or_404
from django.views.decorators.http import require_POST
from django.http import JsonResponse
from django.contrib.humanize.templatetags.humanize import intcomma
from products.models import Product, Stock
from decimal import Decimal
from django.conf import settings
from accounts.models import Destination
from .cart import Cart
from django.db import transaction

def _create_cart_json_response(cart, message=""):
    """カートの現在の状態からJSONレスポンスを生成する共通関数"""
    cart_data = []
    for group in cart:
        items_data = [{
            'id': item['product'].id,
            'name': item['product'].name,
            'quantity': item['quantity'],
            'total_price_formatted': f"{intcomma(item['total_price'])}円",
        } for item in group['items']]
        
        cart_data.append({
            'destination_id': group['destination'].id,
            'destination_name': group['destination'].name,
            'group_total_price_formatted': f"{intcomma(group['group_total_price'])} 円",
            'items': items_data
        })
    
    return JsonResponse({
        'status': 'ok',
        'message': message,
        'cart_groups': cart_data,
        'grand_total_formatted': f"{intcomma(cart.get_grand_total_price())} 円",
        'total_item_count': len(cart)
    })

@require_POST
def update_cart(request):
    """カート内の商品数量を更新する(追加/変更/削除)"""
    cart = Cart(request)
    try:
        product_id = int(request.POST.get('product_id'))
        destination_id = int(request.POST.get('destination_id'))
        mode = request.POST.get('mode', 'add')
        quantity_change = int(request.POST.get('quantity', 1))
    except (TypeError, ValueError):
        return JsonResponse({'status': 'error', 'message': '不正なリクエストです。'}, status=400)

    product = get_object_or_404(Product, id=product_id)
    destination = get_object_or_404(Destination, id=destination_id, user=request.user)

    current_quantity_in_cart = cart.get_item_quantity(product.id, destination.id)
    new_quantity = 0

    if mode == 'add':
        new_quantity = current_quantity_in_cart + quantity_change
    elif mode == 'remove':
        new_quantity = current_quantity_in_cart - quantity_change
    elif mode == 'set':
        new_quantity = quantity_change
    
    new_quantity = max(0, new_quantity)

    try:
        with transaction.atomic():
            stock = Stock.objects.select_for_update().get(variety=product.variety)

            product_weight_for_stock = product.weight_kg
            if product.type == Product.ProductType.SEIMAI:
                seimai_coeff = Decimal(str(settings.SEIMAI_WEIGHT_COEFFICIENT))
                product_weight_for_stock *= seimai_coeff

            if product_weight_for_stock > 0:
                available_count = int(stock.available_kg // product_weight_for_stock)
                if new_quantity > available_count:
                    return JsonResponse({
                        'status': 'error',
                        'message': f'在庫が不足しています。この商品は残り{available_count}点です。'
                    }, status=400)
            elif new_quantity > 0:
                 return JsonResponse({'status': 'error', 'message': 'この商品は現在購入できません。'}, status=400)

    except Stock.DoesNotExist:
         return JsonResponse({'status': 'error', 'message': '在庫情報が見つかりません。'}, status=400)

    cart.update(product=product, destination=destination, quantity=new_quantity)
    
    message = f"「{product.name}」をカートに追加しました。"
    if new_quantity < current_quantity_in_cart:
        message = f"「{product.name}」をカートから減らしました。"
    if new_quantity == 0:
        message = f"「{product.name}」をカートから削除しました。"

    return _create_cart_json_response(cart, message)


@require_POST
def remove_from_cart(request):
    """カートから商品を完全に削除する（サイドバー用）"""
    cart = Cart(request)
    try:
        product_id = int(request.POST.get('product_id'))
        destination_id = int(request.POST.get('destination_id'))
    except (TypeError, ValueError):
        return JsonResponse({'status': 'error', 'message': '不正なリクエストです。'}, status=400)

    product = get_object_or_404(Product, id=product_id)
    destination = get_object_or_404(Destination, id=destination_id, user=request.user)

    cart.remove(product, destination)
    
    if request.headers.get('x-requested-with') == 'XMLHttpRequest':
        return _create_cart_json_response(cart, f"「{product.name}」をカートから削除しました。")
        
    return JsonResponse({'status': 'error', 'message': 'この操作は非同期でのみサポートされています。'}, status=400)
```

#### 3. 手順2：商品一覧ビューの実装 (`products`アプリケーション)

##### **ファイル:** `products/views.py` **(全面的に上書き)**

```python
# products/views.py
from django.shortcuts import render, redirect
from .models import Product, Stock
from accounts.models import Destination
from django.contrib.auth.decorators import login_required
from cart.cart import Cart
from decimal import Decimal
from django.conf import settings


@login_required
def product_list(request):
    products = Product.objects.filter(status=Product.ProductStatus.FOR_SALE).select_related('variety')
    destinations = Destination.objects.filter(user=request.user).order_by('id')
    
    stocks = Stock.objects.all()
    stock_map = {stock.variety.id: stock for stock in stocks}

    active_destination_id = request.session.get('active_destination_id')
    
    if request.method == 'POST' and 'destination_id' in request.POST:
        new_dest_id = request.POST.get('destination_id')
        request.session['active_destination_id'] = int(new_dest_id) if new_dest_id else None
        return redirect('products:product_list')

    if not active_destination_id and destinations.exists():
        active_destination_id = destinations.first().id
        request.session['active_destination_id'] = active_destination_id

    cart = Cart(request)
    cart_quantities = {}
    if active_destination_id:
        active_destination_id = int(active_destination_id)
        dest_cart = cart.cart.get(str(active_destination_id), {})
        for product_id, item_data in dest_cart.get('items', {}).items():
            cart_quantities[int(product_id)] = item_data.get('quantity', 0)

    cart_weight_by_variety = {}
    seimai_coeff = Decimal(str(settings.SEIMAI_WEIGHT_COEFFICIENT))
    product_map = {p.id: p for p in products}

    for product_id, quantity in cart_quantities.items():
        product = product_map.get(product_id)
        if product:
            variety_id = product.variety.id
            weight_in_cart = product.weight_kg * quantity
            
            if product.type == Product.ProductType.SEIMAI:
                weight_in_cart *= seimai_coeff
            
            if variety_id not in cart_weight_by_variety:
                cart_weight_by_variety[variety_id] = Decimal('0')
            cart_weight_by_variety[variety_id] += weight_in_cart

    product_stocks = {}
    for product in products:
        stock = stock_map.get(product.variety.id)
        if stock:
            available_stock_kg = stock.available_kg - cart_weight_by_variety.get(product.variety.id, Decimal('0'))
            
            product_weight_for_stock = product.weight_kg
            if product.type == Product.ProductType.SEIMAI:
                product_weight_for_stock *= seimai_coeff

            if product_weight_for_stock > 0:
                available_count = int(available_stock_kg // product_weight_for_stock)
                product_stocks[product.id] = max(0, available_count)
            else:
                product_stocks[product.id] = 0
        else:
            product_stocks[product.id] = 0

    context = {
        'products': products,
        'destinations': destinations,
        'active_destination_id': active_destination_id,
        'cart_quantities': cart_quantities,
        'product_stocks': product_stocks,
    }
    return render(request, 'products/product_list.html', context)
```

#### 4. 手順3：注文処理の実装 (`orders`アプリケーション)

##### **ファイル:** `orders/views.py` **(全面的に上書き)**

```python
# orders/views.py
from django.http import HttpResponse
from django.template.loader import get_template
from xhtml2pdf import pisa
import os
from django.contrib.staticfiles import finders
from system_settings.models import SystemSetting

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.db import transaction
from django.contrib import messages
from django.conf import settings
from decimal import Decimal
from .models import Order, OrderItem, Package
from products.models import Product, Stock, ProductVariety
from accounts.models import Destination
from cart.cart import Cart

from django.utils import timezone

@login_required
def order_confirm(request):
    cart = Cart(request)
    if len(cart) == 0:
        messages.warning(request, 'カートが空です。')
        return redirect('products:product_list')
    
    # ▼▼▼ 変更点: 注文確認ページ表示前の在庫チェック処理を追加 ▼▼▼
    seimai_coefficient = Decimal(settings.SEIMAI_WEIGHT_COEFFICIENT)
    required_stock_by_variety = {}
    
    for group in cart:
        for item in group['items']:
            product = item['product']
            weight_needed = product.weight_kg * item['quantity']
            if product.type == Product.ProductType.SEIMAI:
                weight_needed *= seimai_coefficient
            
            required_stock_by_variety.setdefault(product.variety.id, Decimal('0'))
            required_stock_by_variety[product.variety.id] += weight_needed

    stocks = Stock.objects.filter(variety_id__in=required_stock_by_variety.keys())
    stock_map = {stock.variety_id: stock for stock in stocks}

    for variety_id, weight_needed in required_stock_by_variety.items():
        stock = stock_map.get(variety_id)
        if not stock or stock.available_kg < weight_needed:
            try:
                variety_name = ProductVariety.objects.get(id=variety_id).name
            except ProductVariety.DoesNotExist:
                variety_name = f"ID:{variety_id}の不明な品種"
            
            messages.error(request, f'申し訳ありません。「{variety_name}」を含む商品の在庫が不足しているため、注文内容の確認に進めません。カートの内容を修正してください。')
            return redirect('products:product_list')
    # ▲▲▲ 変更点ここまで ▲▲▲
    
    stock_error = request.session.pop('stock_error', None)
    
    context = {
        'cart': cart,
        'stock_error': stock_error,
    }
    return render(request, 'orders/confirm.html', context)

@login_required
@transaction.atomic
def order_create(request):
    if request.method != 'POST':
        return redirect('orders:order_confirm')
        
    cart = Cart(request)
    if len(cart) == 0:
        messages.warning(request, 'カートが空のため注文できませんでした。')
        return redirect('products:product_list')
    
    seimai_coefficient = Decimal(settings.SEIMAI_WEIGHT_COEFFICIENT)
    required_stock_by_variety = {}
    
    product_ids_by_variety = {}

    for group in cart:
        for item in group['items']:
            product = item['product']
            weight_needed = product.weight_kg * item['quantity']
            if product.type == Product.ProductType.SEIMAI:
                weight_needed *= seimai_coefficient
            
            required_stock_by_variety.setdefault(product.variety.id, Decimal('0'))
            required_stock_by_variety[product.variety.id] += weight_needed

            if product.variety.id not in product_ids_by_variety:
                product_ids_by_variety[product.variety.id] = set()
            product_ids_by_variety[product.variety.id].add(product.id)

    variety_ids_to_lock = list(required_stock_by_variety.keys())
    stocks = Stock.objects.select_for_update().filter(variety_id__in=variety_ids_to_lock)
    stock_map = {stock.variety_id: stock for stock in stocks}

    for variety_id, weight_needed in required_stock_by_variety.items():
        stock = stock_map.get(variety_id)
        if not stock or stock.available_kg < weight_needed:
            try:
                variety_name = ProductVariety.objects.get(id=variety_id).name
            except ProductVariety.DoesNotExist:
                variety_name = f"ID:{variety_id}の不明な品種"
            
            request.session['stock_error'] = {
                'message': f'「{variety_name}」を含む商品の在庫が不足しています。',
                'variety_id': variety_id,
                'product_ids': list(product_ids_by_variety.get(variety_id, []))
            }
            return redirect('orders:order_confirm')

    for group in cart:
        destination = group['destination']
        order = Order.objects.create(user=request.user, destination=destination, shipping_fee=group['shipping_fee'])
        
        for item in group['items']:
            product = item['product']
            OrderItem.objects.create(order=order, product=product, price_at_order=item['price'], quantity=item['quantity'])
            
            stock = stock_map.get(product.variety.id)
            weight_to_add = product.weight_kg * item['quantity']
            if product.type == Product.ProductType.SEIMAI:
                weight_to_add *= seimai_coefficient
            
            stock.total_ordered_kg += weight_to_add
            stock.save(update_fields=['total_ordered_kg', 'updated_at'])

    cart.clear()
    messages.success(request, 'ご注文ありがとうございました。')
    return redirect('orders:order_history_list')

@login_required
def order_history_list(request):
    show_all = request.GET.get('show_all') == 'true'
    orders_query = Order.objects.filter(user=request.user)

    if not show_all:
        orders_query = orders_query.exclude(status=Order.OrderStatus.CANCELED)

    orders = orders_query.prefetch_related(
        'items', 
        'items__allocations__bag__packageitem__package'
    ).order_by('-created_at')
    
    context = {
        'orders': orders,
        'show_all': show_all,
    }
    return render(request, 'orders/history_list.html', context)


@login_required
def order_detail(request, order_id):
    order = get_object_or_404(
        Order.objects.prefetch_related(
            'items__product',
            'items__allocations__bag__packageitem__package__items__bag__product'
        ), 
        id=order_id, 
        user=request.user
    )
    context = {
        'order': order,
    }
    return render(request, 'orders/detail.html', context)

from django.views.decorators.http import require_POST

@login_required
@require_POST
@transaction.atomic
def order_cancel(request, order_id):
    order = get_object_or_404(Order, id=order_id, user=request.user)

    if order.status != Order.OrderStatus.NEW:
        messages.error(request, 'この注文はキャンセルできません。')
        return redirect('orders:order_detail', order_id=order.id)
    
    seimai_coefficient = Decimal(settings.SEIMAI_WEIGHT_COEFFICIENT)
    stock_updates = {}

    for item in order.items.all():
        weight_to_restore = item.product.weight_kg * item.quantity
        if item.product.type == Product.ProductType.SEIMAI:
            weight_to_restore *= seimai_coefficient
        
        stock_updates.setdefault(item.product.variety_id, Decimal('0'))
        stock_updates[item.product.variety_id] += weight_to_restore

    variety_ids_to_lock = list(stock_updates.keys())
    stocks = Stock.objects.select_for_update().filter(variety_id__in=variety_ids_to_lock)

    for stock in stocks:
        restore_amount = stock_updates.get(stock.variety_id, Decimal('0'))
        stock.total_ordered_kg -= restore_amount
        stock.save(update_fields=['total_ordered_kg', 'updated_at'])

    order.status = Order.OrderStatus.CANCELED
    order.save()

    messages.success(request, f'注文(ORD-{order.id:06d})をキャンセルしました。')
    return redirect('orders:order_history_list')

def link_callback(uri, rel):
    result = finders.find(uri)
    if result:
        if not isinstance(result, (list, tuple)):
            result = [result]
        return result[0]
    return uri

@login_required
def generate_invoice_pdf(request):
    show_all = request.GET.get('show_all') == 'true'
    orders_query = Order.objects.filter(user=request.user)
    if not show_all:
        orders_query = orders_query.exclude(status=Order.OrderStatus.CANCELED)
    orders = orders_query.order_by('created_at')

    if not orders.exists():
        messages.error(request, '請求書を作成する対象の注文がありません。')
        return redirect('orders:order_history_list')

    grand_total = sum(order.total_price for order in orders)
    
    system_settings = SystemSetting.load()
    template_path = 'orders/invoice_template.html'
    context = {
        'orders': orders,
        'grand_total': grand_total,
        'customer': request.user,
        'settings': system_settings,
    }
    
    response = HttpResponse(content_type='application/pdf')
    filename = f"invoice_{request.user.username}_{timezone.now().strftime('%Y%m%d')}.pdf"
    response['Content-Disposition'] = f'attachment; filename="{filename}"'

    template = get_template(template_path)
    html = template.render(context, request=request)

    pisa_status = pisa.CreatePDF(
        html.encode('utf-8'), 
        dest=response, 
        encoding='utf-8',
        link_callback=link_callback
    )

    if pisa_status.err:
        return HttpResponse('PDFの生成中にエラーが発生しました。')
    return response

from django.http import JsonResponse
from django.urls import reverse

@login_required
@require_POST
@transaction.atomic
def order_update(request, order_id):
    order = get_object_or_404(Order.objects.select_related('user').prefetch_related('items__product__variety'), id=order_id, user=request.user)

    if not order.is_cancelable:
        return JsonResponse({'success': False, 'message': 'この注文は変更できません。'})
    
    seimai_coefficient = Decimal(settings.SEIMAI_WEIGHT_COEFFICIENT)
    original_total_weight = order.get_total_weight_in_genmai()
    
    updates = {}
    new_items_data = {}
    for item in order.items.all():
        new_quantity_str = request.POST.get(f'quantity_{item.id}')
        if not new_quantity_str or not new_quantity_str.isdigit():
            return JsonResponse({'success': False, 'message': '数量は有効な数字で入力してください。'})
        new_quantity = int(new_quantity_str)
        updates[item.id] = new_quantity
        new_items_data[item.product.variety.id] = new_items_data.get(item.product.variety.id, Decimal('0'))
        weight = item.product.weight_kg * new_quantity
        if item.product.type == Product.ProductType.SEIMAI:
            weight *= seimai_coefficient
        new_items_data[item.product.variety.id] += weight

    new_total_weight = sum(new_items_data.values())
    weight_diff = new_total_weight - original_total_weight

    if weight_diff > 0:
        variety_ids_to_lock = list(new_items_data.keys())
        stocks = Stock.objects.select_for_update().filter(variety_id__in=variety_ids_to_lock)
        stock_map = {s.variety_id: s for s in stocks}
        
        current_available_in_db = sum(s.available_kg for s in stocks)
        if current_available_in_db < weight_diff:
            return JsonResponse({'success': False, 'message': f'在庫が不足しています。追加で {weight_diff} kg 必要ですが、確保できません。'})

    # 在庫更新と注文明細の更新
    for item in order.items.all():
        item.quantity = updates[item.id]
        if item.quantity > 0:
            item.save(update_fields=['quantity'])
        else:
            item.delete()

    if weight_diff != 0:
        variety_ids_to_update = list(new_items_data.keys())
        stocks_to_update = Stock.objects.select_for_update().filter(variety_id__in=variety_ids_to_update)
        for stock in stocks_to_update:
            # 注文変更による総注文量の差分を更新
            change_for_this_variety = new_items_data.get(stock.variety_id, 0) - order.get_total_weight_in_genmai_for_variety(stock.variety_id)
            stock.total_ordered_kg += change_for_this_variety
            stock.save(update_fields=['total_ordered_kg', 'updated_at'])

    if not order.items.exists():
        order.delete()
        # この場合、在庫は元の状態に戻っているはず
        messages.success(request, f'注文(ORD-{order.id:06d})の全商品を削除したため、注文は自動的にキャンセルされました。')
        return JsonResponse({'success': True, 'redirect_url': reverse('orders:order_history_list')})

    messages.success(request, f'注文(ORD-{order.id:06d})を更新しました。')
    return JsonResponse({'success': True, 'redirect_url': reverse('orders:order_detail', args=[order.id])})
```
