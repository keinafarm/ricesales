この手順書は、袋詰・梱包・発送という一連の出荷作業をシステム化するものであり、リファクタリングで新設された`mg_workflow`アプリケーションにその機能を集約します。

---

### **【作業前確認】対象ファイル一覧**

今回のタスク「管理者向け出荷ワークフロー機能の実装」では、以下の聖典ファイルを参照・作成します。お手元のファイル群にこれらが全て含まれているか、ご確認ください。

* **バックエンド (新規アプリケーション):**
  * `mg_workflow/api_packaging.py`
  * `mg_workflow/api_shipping.py`
  * `mg_workflow/views.py`
  * `mg_workflow/urls.py`
* **フロントエンド (新規アプリケーション):**
  * `mg_workflow/templates/mg_workflow/bagging_list.html`
  * `mg_workflow/templates/mg_workflow/packaging_board.html`
  * `mg_workflow/templates/mg_workflow/shipping_list.html`
  * `mg_workflow/static/js/packaging_board.js`
  * `mg_workflow/static/js/shipping_list.js`
* **プロジェクト全体・共通部分:**
  * `config/settings.py` （変更）
  * `dashboard/urls.py` （変更）
  * `dashboard/context_processors.py` （変更）
  * `templates/base_management.html` （変更）
* **参照するモデル:**
  * `orders/models.py` （【手順書21】にて定義済み）

上記ファイルが揃っていることを確認いたしましたので、実装手順書を作成します。

---

### **【機能単位】管理者向け出荷ワークフロー機能 実装手順書 (Ver. 3.0)**

#### 1. 目的

この手順書は、`【機能単位】管理者向け顧客管理機能 実装手順書 (Ver. 3.0)`までが完了した状態から、管理者が注文受付後に行う一連の出荷作業（袋詰 → 梱包 → 発送）を、新設された`mg_workflow`アプリケーションとして実装するための公式ドキュメントです。

#### 2. 手順1：システム設定の拡張

##### **ファイル:** `config/settings.py` **(全面的に上書き)**

* パッケージングの重量計算に使用する定数を追加します。

```python
# config/settings.py
import os
from pathlib import Path
from dotenv import load_dotenv
import socket

BASE_DIR = Path(__file__).resolve().parent.parent

load_dotenv()

SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')
DEBUG = os.getenv('DJANGO_DEBUG', 'False') == 'True'

# .envファイルから読み込んだホスト名をリスト化
ALLOWED_HOSTS = os.getenv('DJANGO_ALLOWED_HOSTS', '').split(',')

if DEBUG:
    # 開発時はlocalhostを追加
    ALLOWED_HOSTS.extend(['localhost', '127.0.0.1'])
else:
    # 本番時はTraefikからの内部アクセス用にlocalhostを追加
    ALLOWED_HOSTS.append('localhost')

CSRF_TRUSTED_ORIGINS = os.getenv('DJANGO_CSRF_TRUSTED_ORIGINS', '').split(',')

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'whitenoise.runserver_nostatic',
    'django.contrib.staticfiles',
    'django.contrib.humanize',
    'bootstrap5',
    'django_extensions',
    'accounts.apps.AccountsConfig',
    'products.apps.ProductsConfig',
    'orders.apps.OrdersConfig',
    'cart.apps.CartConfig',
    'system_settings.apps.SystemSettingsConfig',
    'dashboard.apps.DashboardConfig',
    'mg_orders.apps.MgOrdersConfig',
    'mg_customers.apps.MgCustomersConfig',
    'mg_masters.apps.MgMastersConfig',
    'mg_workflow.apps.MgWorkflowConfig',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

if DEBUG:
    INSTALLED_APPS.append('debug_toolbar')
    MIDDLEWARE.append('debug_toolbar.middleware.DebugToolbarMiddleware')

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'cart.context_processors.cart_context',
                'dashboard.context_processors.bag_stock_summary',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': os.getenv('MYSQL_DATABASE'),
        'USER': os.getenv('MYSQL_USER'),
        'PASSWORD': os.getenv('MYSQL_PASSWORD'),
        'HOST': os.getenv('MYSQL_HOST', 'db'),
        'PORT': '3306',
        'OPTIONS': {'charset': 'utf8mb4'},
    }
}

AUTH_PASSWORD_VALIDATORS = []

LANGUAGE_CODE = 'ja'
TIME_ZONE = 'Asia/Tokyo'
USE_I18N = True
USE_L10N = True
USE_THOUSAND_SEPARATOR = True
NUMBER_GROUPING = 3
USE_TZ = True

STATIC_URL = 'static/'
STATICFILES_DIRS = [BASE_DIR / "static"]
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

INTERNAL_IPS = [ "127.0.0.1", ]
if DEBUG:
    try:
        hostname, _, ips = socket.gethostbyname_ex(socket.gethostname())
        INTERNAL_IPS.extend([ip[: ip.rfind(".")] + ".1" for ip in ips])
    except socket.gaierror:
        pass

# --- My Settings ---
AUTH_USER_MODEL = 'accounts.User'
LOGIN_URL = 'accounts:login'
LOGIN_REDIRECT_URL = 'products:product_list'
LOGOUT_REDIRECT_URL = 'accounts:login'
CART_SESSION_ID = 'cart'
CART_HYBRID_THRESHOLD = 3
NORMAL_SHIPPING_FEE = 1200
REMOTE_SHIPPING_FEE = 1800
SEIMAI_WEIGHT_COEFFICIENT = 1.1
# ▼▼▼ 変更点: 梱包関連の定数を追加 ▼▼▼
PACKAGE_MAX_WEIGHT_KG = 25.0
DEFAULT_BOX_WEIGHT_KG = 0.5
# ▲▲▲ 変更点ここまで ▲▲▲

if not DEBUG:
    SECURE_SSL_REDIRECT = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
```

##### **ファイル:** `dashboard/context_processors.py` **(全面的に上書き)**

* サイドバーに常に「袋在庫サマリー」を表示するためのバックエンドロジックを実装します。

```python
# dashboard/context_processors.py
from django.db.models import Sum, Count, Q
from orders.models import Order, OrderItem, Bag, PackageItem

def bag_stock_summary(request):
    """
    サイドバーの在庫サマリー（物理ベース）
    - 総数: 注文数 (ACCEPTED)
    - 未袋: 注文数 - 準備済み袋(prepared=True)の総数
    - 袋米: 準備済み(prepared) かつ 未梱包(packageitem=None) の袋数
    - 箱入: 準備済み(prepared) かつ 箱入(packageitem!=None) の袋数
    """
    if not request.user.is_authenticated or not request.user.is_staff:
        return {}

    required_qs = (
        OrderItem.objects
        .filter(order__status=Order.OrderStatus.ACCEPTED)
        .values('product_id', 'product__name')
        .annotate(q=Sum('quantity'))
    )
    by_prod = {}
    for r in required_qs:
        pid = r['product_id']
        by_prod[pid] = {
            'name': r['product__name'],
            'total_ordered': int(r['q'] or 0),
            'prepared_total': 0,
            'packed_total': 0,
        }

    prepared_bags_qs = (
        Bag.objects
        .filter(prepared=True)
        .values('product_id')
        .annotate(
            total_prepared_count=Count('id'),
            total_packed_count=Count('packageitem', filter=Q(packageitem__isnull=False))
        )
    )

    for row in prepared_bags_qs:
        pid = row['product_id']
        if pid in by_prod:
            by_prod[pid]['prepared_total'] = int(row['total_prepared_count'] or 0)
            by_prod[pid]['packed_total'] = int(row['total_packed_count'] or 0)

    rows = []
    for pid, data in by_prod.items():
        total_ordered = data['total_ordered']
        prepared_total = data['prepared_total']
        packed_total = data['packed_total']

        unbagged_count = max(0, total_ordered - prepared_total)
        
        unpacked_count = max(0, prepared_total - packed_total)

        rows.append({
            'name': data['name'],
            'total': total_ordered,
            'unbagged': unbagged_count,
            'bag_rice': unpacked_count,
            'boxed': packed_total,
        })

    rows.sort(key=lambda x: x['name'])
    return {'bag_stock_summary': rows}
```



#### 3. 手順2：バックエンドの実装 (`mg_workflow`アプリケーション)

出荷ワークフロー機能のロジック、API、URL定義を`mg_workflow`アプリケーションとして新規に作成します。

##### **ファイル:** `mg_workflow/api_packaging.py` **(新規作成)**

* 自動引当ボードの全ての非同期操作（状態取得、箱・袋・予約のCRUD、自動提案、ロック制御など）を処理するAPIを実装します。

```python
# mg_workflow/api_packaging.py
from __future__ import annotations
import json
from decimal import Decimal
from typing import Any, Dict, List, Tuple
from collections import defaultdict
from django.conf import settings
from django.db import transaction
from django.db.models import Sum, Count, Q
from django.http import JsonResponse, HttpRequest
from django.shortcuts import get_object_or_404
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_protect
from django.contrib.admin.views.decorators import staff_member_required

from orders.models import Order, OrderItem, Bag, Allocation, Package, PackageItem, PackagePlanItem
from products.models import Product
from accounts.models import Destination

def _json(request: HttpRequest) -> Dict[str, Any]:
    try:
        body = request.body.decode("utf-8") or "{}"
        return json.loads(body)
    except json.JSONDecodeError:
        return {}
def _bad_request(message: str, *, code: str = "invalid_request", extra: Dict[str, Any] | None = None):
    payload = {"ok": False, "error": {"code": code, "message": message}}
    if extra: payload["error"].update(extra)
    return JsonResponse(payload, status=400)
def _ok(data: Dict[str, Any] | None = None, *, status: int = 200):
    payload = {"ok": True}
    if data: payload.update(data)
    return JsonResponse(payload, status=status)
def _pkg_physical_weight(package: Package) -> Decimal:
    box_w = Decimal(str(getattr(settings, "DEFAULT_BOX_WEIGHT_KG", 0.5)))
    bag_w = (Bag.objects.filter(packageitem__package=package).aggregate(total=Sum('product__weight_kg'))["total"] or Decimal("0"))
    return box_w + Decimal(str(bag_w))
def _pkg_weight_with_plans(package: Package) -> Decimal:
    w = _pkg_physical_weight(package)
    for pi in PackagePlanItem.objects.select_related('product').filter(package=package):
        w += Decimal(str(pi.product.weight_kg)) * Decimal(pi.quantity)
    return w
def _assert_pkg_capacity_with_plans_plus(package: Package, extra_weight_kg: Decimal) -> None:
    max_w = Decimal(str(getattr(settings, "PACKAGE_MAX_WEIGHT_KG", 25.0)))
    if _pkg_weight_with_plans(package) + extra_weight_kg > max_w:
        raise ValueError(f"箱重量上限 {max_w}kg（予約含む）を超過します。")
def _ordered_qty(destination_id: int, product_id: int) -> int:
    return int(OrderItem.objects.filter(order__destination_id=destination_id, order__status=Order.OrderStatus.ACCEPTED, product_id=product_id).aggregate(total=Sum('quantity'))["total"] or 0)
def _allocated_qty(destination_id: int, product_id: int) -> int:
    return int(Allocation.objects.filter(order_item__order__destination_id=destination_id, order_item__order__status=Order.OrderStatus.ACCEPTED, order_item__product_id=product_id).count())
def _planned_qty_dest(destination_id: int, product_id: int) -> int:
    return int(PackagePlanItem.objects.filter(package__destination_id=destination_id, product_id=product_id).aggregate(total=Sum('quantity'))["total"] or 0)
def _allocatable_remaining(destination_id: int, product_id: int) -> int:
    ordered = _ordered_qty(destination_id, product_id)
    allocated = _allocated_qty(destination_id, product_id)
    planned = _planned_qty_dest(destination_id, product_id)
    return max(0, ordered - allocated - planned)
def _pick_prepared_bags(product_id: int, count: int) -> List[Bag]:
    return list(Bag.objects.select_for_update(skip_locked=True).filter(prepared=True, product_id=product_id, allocation__isnull=True)[:count])
def _iter_order_items_with_demand(destination_id: int, product_id: int):
    q = (OrderItem.objects.filter(order__destination_id=destination_id, order__status=Order.OrderStatus.ACCEPTED, product_id=product_id).annotate(alloc_count=Count('allocations')).order_by('order_id', 'id').values('id', 'quantity', 'alloc_count'))
    for row in q:
        remaining = int(row['quantity']) - int(row['alloc_count'] or 0)
        if remaining > 0: yield (remaining, row['id'])

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageCreateView(View):
    def post(self, request: HttpRequest):
        data = _json(request)
        destination_id = data.get("destination_id")
        if not destination_id: return _bad_request("destination_id は必須です。")
        destination = get_object_or_404(Destination, pk=destination_id)
        package = Package.objects.create(destination=destination, status=Package.PackageStatus.PACKAGING)
        return _ok({"package": {"id": package.id, "destination_id": destination.id}}, status=201)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageDeleteView(View):
    def delete(self, request: HttpRequest, package_id: int):
        package = get_object_or_404(Package, pk=package_id)
        if package.items.exists(): return _bad_request("箱に袋が入っているため削除できません。先に中身を取り出してください。")
        if package.plan_items.exists(): return _bad_request("箱に予約があるため削除できません。先に予約を0にしてください。")
        package.delete()
        return _ok({"deleted": True}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageItemCreateView(View):
    @transaction.atomic
    def post(self, request: HttpRequest):
        data = _json(request)
        try:
            destination_id = int(data.get("destination_id"))
            product_id = int(data.get("product_id"))
            count = int(data.get("count", 0))
            package_id = int(data.get("package_id"))
        except (TypeError, ValueError):
            return _bad_request("destination_id, product_id, count, package_id は整数で指定してください。")
        if count <= 0: return _bad_request("count は 1 以上で指定してください。")
        package = get_object_or_404(Package, pk=package_id)
        if package.destination_id != destination_id: return _bad_request("package の宛先と destination_id が一致しません。")
        product = get_object_or_404(Product, pk=product_id)
        extra_weight = Decimal(str(product.weight_kg)) * Decimal(count)
        try:
            _assert_pkg_capacity_with_plans_plus(package, extra_weight)
        except ValueError as e:
            return _bad_request(str(e), code="over_weight")
        created_items = []
        bags_to_process = count
        unpacked_bags = Bag.objects.select_for_update(skip_locked=True).filter(
            prepared=True,
            product_id=product_id,
            allocation__order_item__order__destination_id=destination_id,
            packageitem__isnull=True
        )[:bags_to_process]
        for bag in unpacked_bags:
            pi = PackageItem.objects.create(package=package, bag=bag)
            created_items.append({"package_item_id": pi.id, "bag_id": bag.id, "product_name": product.name})
        bags_to_process -= len(unpacked_bags)
        if bags_to_process > 0:
            remaining_demand = _allocatable_remaining(destination_id, product_id)
            if bags_to_process > remaining_demand:
                return _bad_request("宛先合計の注文枠（予約含む）を超えています。", extra={"remaining": remaining_demand, "requested": bags_to_process})
            new_bags = _pick_prepared_bags(product_id, bags_to_process)
            if len(new_bags) < bags_to_process:
                return _bad_request("準備済み（未引当）の袋が不足しています。", extra={"available": len(new_bags)})
            demand_iter = _iter_order_items_with_demand(destination_id, product_id)
            alloc_targets: List[int] = []
            for remaining_needed, order_item_id in demand_iter:
                take = min(remaining_needed, bags_to_process - len(alloc_targets))
                alloc_targets.extend([order_item_id] * take)
                if len(alloc_targets) >= bags_to_process: break
            if len(alloc_targets) < bags_to_process:
                return _bad_request("割当先の注文明細が不足しています。")
            for bag, order_item_id in zip(new_bags, alloc_targets):
                Allocation.objects.create(order_item_id=order_item_id, bag=bag)
                pi = PackageItem.objects.create(package=package, bag=bag)
                created_items.append({"package_item_id": pi.id, "bag_id": bag.id, "product_name": product.name})
        return _ok({"created": created_items}, status=201)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageItemDeleteView(View):
    @transaction.atomic
    def delete(self, request: HttpRequest, package_item_id: int):
        pi = get_object_or_404(PackageItem.objects.select_related('package', 'bag'), pk=package_item_id)
        if hasattr(pi.bag, 'allocation'):
            pi.bag.allocation.delete()
        pi.delete()
        return _ok({"deleted": True}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageItemMoveView(View):
    @transaction.atomic
    def patch(self, request: HttpRequest, package_item_id: int):
        data = _json(request)
        try: to_package_id = int(data.get("to_package_id"))
        except (TypeError, ValueError): return _bad_request("to_package_id は整数で指定してください。")
        pi = get_object_or_404(PackageItem.objects.select_related('package'), pk=package_item_id)
        src_pkg, dst_pkg = pi.package, get_object_or_404(Package, pk=to_package_id)
        
        if src_pkg.destination_id != dst_pkg.destination_id: return _bad_request("移動元と移動先の宛先が一致しません。")
        bag_w = Decimal(str(pi.bag.product.weight_kg))
        try: _assert_pkg_capacity_with_plans_plus(dst_pkg, bag_w)
        except ValueError as e: return _bad_request(str(e), code="over_weight")
        pi.package = dst_pkg
        pi.save(update_fields=["package"])
        return _ok({"moved": True, "package_item_id": pi.id, "to_package_id": dst_pkg.id}, status=200)

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class BoardStateView(View):
    def get(self, request: HttpRequest):
        prepared_qs = (Bag.objects.filter(prepared=True, packageitem__isnull=True).values('product_id', 'product__name', 'product__weight_kg').annotate(qty=Count('id')).order_by('product__name'))
        prepared_groups = [{"product_id": r["product_id"], "product_name": r["product__name"], "weight_kg": float(r["product__weight_kg"]), "qty": int(r["qty"])} for r in prepared_qs]
        dest_ids = set(Destination.objects.filter(Q(order__status=Order.OrderStatus.ACCEPTED) | Q(package__isnull=False)).values_list('id', flat=True))
        destinations_out: List[Dict[str, Any]] = []
        max_weight = Decimal(str(getattr(settings, "PACKAGE_MAX_WEIGHT_KG", 25.0)))
        for did in sorted(dest_ids):
            dest = Destination.objects.get(pk=did)
            packages = []
            pkg_qs = Package.objects.filter(destination_id=did).order_by('id')
            
            for pkg in pkg_qs:
                items = []
                for pi in PackageItem.objects.select_related('bag__product').filter(package=pkg).order_by('id'):
                    items.append({"package_item_id": pi.id, "bag_id": pi.bag.id, "product_id": pi.bag.product.id, "product_name": pi.bag.product.name, "weight_kg": float(pi.bag.product.weight_kg)})
                plans = []
                for pl in PackagePlanItem.objects.select_related('product').filter(package=pkg).order_by('id'):
                    plans.append({"plan_item_id": pl.id, "product_id": pl.product_id, "product_name": pl.product.name, "weight_kg": float(pl.product.weight_kg), "quantity": int(pl.quantity)})
                current_weight = _pkg_weight_with_plans(pkg)
                packages.append({
                    "id": pkg.id,
                    "label": getattr(pkg, "label", None),
                    "lock_status": pkg.lock_status,
                    "status": pkg.status,
                    "items": items,
                    "plans": plans,
                    "current_weight_kg": float(current_weight),
                    "max_weight_kg": float(max_weight),
                })
            destinations_out.append({"id": dest.id, "name": dest.name, "packages": packages})
            
        ordered_map: Dict[Tuple[int,int], int] = {}
        for row in (OrderItem.objects.filter(order__status=Order.OrderStatus.ACCEPTED).values('order__destination_id', 'product_id').annotate(q=Sum('quantity'))):
            ordered_map[(row['order__destination_id'], row['product_id'])] = int(row['q'] or 0)
        allocated_map: Dict[Tuple[int,int], int] = {}
        for row in (Allocation.objects.filter(order_item__order__status=Order.OrderStatus.ACCEPTED).values('order_item__order__destination_id', 'order_item__product_id').annotate(c=Count('id'))):
            key = (row['order_item__order__destination_id'], row['order_item__product_id'])
            allocated_map[key] = int(row['c'] or 0)
        placeholders = []
        for (dest_id, product_id), q in ordered_map.items():
            alloc = allocated_map.get((dest_id, product_id), 0)
            remaining = max(0, q - alloc)
            if remaining > 0:
                product = Product.objects.get(pk=product_id)
                placeholders.append({"destination_id": dest_id, "product_id": product_id, "product_name": product.name, "weight_kg": float(product.weight_kg), "remaining": remaining})
        return _ok({"prepared_groups": prepared_groups, "destinations": destinations_out, "placeholders": placeholders}, status=200)

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PreparedBagsView(View):
    def get(self, request: HttpRequest):
        prepared_qs = (Bag.objects.filter(prepared=True, allocation__isnull=True).values('product_id', 'product__name', 'product__weight_kg').annotate(qty=Count('id')).order_by('product__name'))
        prepared_groups = [{"product_id": r["product_id"], "product_name": r["product__name"], "weight_kg": float(r["product__weight_kg"]), "qty": int(r["qty"])} for r in prepared_qs]
        return _ok({"prepared_groups": prepared_groups}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PlanItemUpsertView(View):
    @transaction.atomic
    def post(self, request: HttpRequest):
        data = _json(request)
        try:
            package_id = int(data.get("package_id"))
            product_id = int(data.get("product_id"))
            quantity = int(data.get("quantity"))
        except (TypeError, ValueError): return _bad_request("package_id, product_id, quantity は整数で指定してください。")
        if quantity < 0: return _bad_request("quantity は 0 以上で指定してください。")
        package = get_object_or_404(Package, pk=package_id)
        product = get_object_or_404(Product, pk=product_id)
        ordered, allocated, planned_total = _ordered_qty(package.destination_id, product_id), _allocated_qty(package.destination_id, product_id), _planned_qty_dest(package.destination_id, product_id)
        cur = PackagePlanItem.objects.filter(package=package, product=product).first()
        current_qty = cur.quantity if cur else 0
        delta = quantity - current_qty
        if allocated + planned_total + delta > ordered:
            return _bad_request("宛先合計の注文枠（予約含む）を超えています。", extra={"ordered": ordered, "allocated": allocated, "planned_total": planned_total, "delta": delta})
        delta_w = Decimal(str(product.weight_kg)) * Decimal(delta if delta > 0 else 0)
        try: _assert_pkg_capacity_with_plans_plus(package, delta_w)
        except ValueError as e: return _bad_request(str(e), code="over_weight")
        if quantity == 0:
            if cur: cur.delete()
            return _ok({"upsert": {"deleted": True}}, status=200)
        else:
            if cur:
                cur.quantity = quantity
                cur.save(update_fields=["quantity", "updated_at"])
                obj = cur
            else:
                obj = PackagePlanItem.objects.create(package=package, product=product, quantity=quantity)
            return _ok({"upsert": {"plan_item_id": obj.id, "package_id": package.id, "product_id": product.id, "product_name": product.name, "quantity": obj.quantity}}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PlanItemConsumeView(View):
    @transaction.atomic
    def post(self, request: HttpRequest):
        data = _json(request)
        try:
            package_id = int(data.get("package_id"))
            product_id = int(data.get("product_id"))
            count = int(data.get("count"))
        except (TypeError, ValueError): return _bad_request("package_id, product_id, count は整数で指定してください。")
        if count <= 0: return _bad_request("count は 1 以上で指定してください。")
        package = get_object_or_404(Package, pk=package_id)
        product = get_object_or_404(Product, pk=product_id)
        plan = PackagePlanItem.objects.filter(package=package, product=product).first()
        if not plan or plan.quantity < count: return _bad_request("予約数量が不足しています。")
        bags = _pick_prepared_bags(product_id, count)
        if len(bags) < count: return _bad_request("準備済み（未引当）の袋が不足しています。", extra={"available": len(bags)})
        demand_iter = _iter_order_items_with_demand(package.destination_id, product_id)
        alloc_targets: List[int] = []
        for remaining_needed, order_item_id in demand_iter:
            take = min(remaining_needed, count - len(alloc_targets))
            alloc_targets.extend([order_item_id] * take)
            if len(alloc_targets) >= count: break
        if len(alloc_targets) < count: return _bad_request("割当先の注文明細が不足しています。")
        created_items = []
        for bag, order_item_id in zip(bags, alloc_targets):
            alloc = Allocation.objects.create(order_item_id=order_item_id, bag=bag)
            pi = PackageItem.objects.create(package=package, bag=bag)
            created_items.append({"package_item_id": pi.id, "bag_id": bag.id, "allocation_id": alloc.id, "product_name": product.name})
        plan.quantity -= count
        if plan.quantity <= 0:
            plan.delete()
            remaining = 0
        else:
            plan.save(update_fields=["quantity", "updated_at"])
            remaining = plan.quantity
        return _ok({"consumed": created_items, "remaining_plan_qty": remaining}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageLabelUpdateView(View):
    def patch(self, request: HttpRequest, package_id: int):
        data = _json(request)
        if "label" not in data: return _bad_request("label は必須です。")
        label = (data.get("label") or "").strip()
        pkg = get_object_or_404(Package, pk=package_id)
        if len(label) > 50: return _bad_request("label は50文字以内で指定してください。", code="too_long")
        pkg.label = label if label else None
        pkg.save(update_fields=["label", "updated_at"])
        return _ok({"package": {"id": pkg.id, "label": pkg.label}}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageLockStatusUpdateView(View):
    def patch(self, request: HttpRequest, package_id: int):
        data = _json(request)
        lock_status = data.get("lock_status")
        valid_statuses = [s[0] for s in Package.LockStatus.choices]
        if lock_status not in valid_statuses:
            return _bad_request(f"lock_status は {', '.join(valid_statuses)} のいずれかで指定してください。", code="invalid_lock_status")
        pkg = get_object_or_404(Package, pk=package_id)
        pkg.lock_status = lock_status
        pkg.save(update_fields=["lock_status", "updated_at"])
        return _ok({"package": {"id": pkg.id, "lock_status": pkg.lock_status}}, status=200)

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class SidebarStockSummaryView(View):
    def get(self, request: HttpRequest):
        required_qs = (OrderItem.objects.filter(order__status='ACCEPTED').values('product__id', 'product__name').annotate(total_ordered=Sum('quantity')).order_by('product__name'))
        summary_map = {r['product__id']: {'name': r['product__name'], 'total_ordered': r['total_ordered'] or 0, 'prepared_total': 0, 'bagged_unpacked': 0, 'bagged_packed': 0} for r in required_qs}
        prepared_bags_qs = (Bag.objects.filter(prepared=True).values('product_id').annotate(total_prepared_count=Count('id'), total_packed_count=Count('packageitem', filter=Q(packageitem__isnull=False))))
        for row in prepared_bags_qs:
            pid = row['product_id']
            if pid in summary_map:
                total_prepared = row['total_prepared_count'] or 0
                total_packed = row['total_packed_count'] or 0
                summary_map[pid]['prepared_total'] = total_prepared
                summary_map[pid]['bagged_packed'] = total_packed
                summary_map[pid]['bagged_unpacked'] = total_prepared - total_packed
        summary_list = []
        for pid, data in summary_map.items():
            total_ordered = data['total_ordered']
            prepared_total = data['prepared_total']
            unbagged_count = max(0, total_ordered - prepared_total)
            summary_list.append({'name': data['name'], 'total': total_ordered, 'unbagged': unbagged_count, 'bag_rice': data['bagged_unpacked'], 'boxed': data['bagged_packed']})
        return JsonResponse({"bag_stock_summary": summary_list})

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class AllocatableItemsView(View):
    def get(self, request: HttpRequest):
        try:
            destination_id = int(request.GET.get("destination_id"))
        except (TypeError, ValueError):
            return _bad_request("destination_id は必須のクエリパラメータです。")
        demand_map = {}
        ordered_items = OrderItem.objects.filter(order__destination_id=destination_id, order__status=Order.OrderStatus.ACCEPTED).values('product_id', 'product__name', 'product__weight_kg').annotate(qty=Sum('quantity'))
        for item in ordered_items:
            demand_map[item['product_id']] = {"product_id": item['product_id'], "product_name": item['product__name'], "weight_kg": float(item['product__weight_kg']), "ordered": item['qty'] or 0, "allocated": 0, "planned": 0}
        allocated_items = Allocation.objects.filter(order_item__order__destination_id=destination_id).values('order_item__product_id').annotate(qty=Count('id'))
        for item in allocated_items:
            pid = item['order_item__product_id']
            if pid in demand_map:
                demand_map[pid]['allocated'] = item['qty'] or 0
        planned_items = PackagePlanItem.objects.filter(package__destination_id=destination_id).values('product_id').annotate(qty=Sum('quantity'))
        for item in planned_items:
            pid = item['product_id']
            if pid in demand_map:
                demand_map[pid]['planned'] = int(item['qty'] or 0)
        stock_map = {}
        prepared_bags = Bag.objects.filter(prepared=True, allocation__isnull=True).values('product_id').annotate(qty=Count('id'))
        for bag in prepared_bags:
            stock_map[bag['product_id']] = bag['qty'] or 0
        result = []
        for pid, data in demand_map.items():
            remaining_demand = data['ordered'] - (data['allocated'] + data['planned'])
            if remaining_demand > 0:
                available_stock = stock_map.get(pid, 0)
                result.append({"product_id": pid, "product_name": data['product_name'], "weight_kg": data['weight_kg'], "remaining_demand": remaining_demand, "available_stock": available_stock})
        result.sort(key=lambda x: x['product_name'])
        return _ok({"allocatable_items": result})

def _pack_bags(bags, max_weight, box_weight, existing_packages=None):
    sorted_bags = sorted(bags, key=lambda b: Decimal(str(b.product.weight_kg)), reverse=True)
    packages = []
    if existing_packages:
        packages = existing_packages
    for bag in sorted_bags:
        bag_weight = Decimal(str(bag.product.weight_kg))
        bag_variety_id = bag.product.variety_id
        target_box = None
        box_for_same_variety = None
        for pkg in packages:
            if bag_variety_id in pkg['variety_ids'] and pkg['weight'] + bag_weight <= max_weight:
                box_for_same_variety = pkg
                break
        if box_for_same_variety:
            target_box = box_for_same_variety
        else:
            box_for_any = None
            for pkg in packages:
                if pkg['weight'] + bag_weight <= max_weight:
                    box_for_any = pkg
                    break
            if box_for_any:
                target_box = box_for_any
        if target_box:
            target_box['bags'].append(bag)
            target_box['weight'] += bag_weight
            target_box['variety_ids'].add(bag_variety_id)
        else:
            packages.append({'id': None, 'bags': [bag], 'weight': box_weight + bag_weight, 'variety_ids': {bag_variety_id}})
    return packages

def _get_repack_assets(destination: Destination) -> Tuple[List[Package], List[Dict], List[Bag]]:
    locked_packages = []
    append_only_packages_for_algo = []
    unlocked_packages = []
    existing_packages_qs = Package.objects.prefetch_related('items__bag__product__variety').filter(destination=destination)
    for pkg in existing_packages_qs:
        if pkg.lock_status == Package.LockStatus.LOCKED:
            locked_packages.append(pkg)
        elif pkg.lock_status == Package.LockStatus.UNLOCKED:
            unlocked_packages.append(pkg)
        elif pkg.lock_status == Package.LockStatus.APPEND_ONLY:
            current_bags = list(item.bag for item in pkg.items.all())
            append_only_packages_for_algo.append({'id': pkg.id, 'bags': current_bags, 'weight': _pkg_weight_with_plans(pkg), 'variety_ids': {b.product.variety_id for b in current_bags}, 'initial_bag_ids': {b.id for b in current_bags}})
    demand_map = {item['product_id']: item['total_ordered'] for item in OrderItem.objects.filter(order__destination=destination, order__status=Order.OrderStatus.ACCEPTED).values('product_id').annotate(total_ordered=Sum('quantity'))}
    all_destination_bags = []
    allocated_bags = Bag.objects.filter(allocation__order_item__order__destination=destination)
    all_destination_bags.extend(allocated_bags)
    allocated_counts = {pid: count for pid, count in Allocation.objects.filter(order_item__order__destination=destination).values_list('order_item__product_id').annotate(c=Count('id'))}
    for product_id, total_ordered in demand_map.items():
        needed = total_ordered - allocated_counts.get(product_id, 0)
        if needed > 0:
            unallocated = Bag.objects.filter(prepared=True, allocation__isnull=True, product_id=product_id)[:needed]
            all_destination_bags.extend(unallocated)
    all_destination_bag_ids = {b.id for b in all_destination_bags}
    untouchable_bag_ids = set()
    for pkg in locked_packages:
        untouchable_bag_ids.update(item.bag_id for item in pkg.items.all())
    for pkg_data in append_only_packages_for_algo:
        untouchable_bag_ids.update(b.id for b in pkg_data['bags'])
    movable_bag_ids = all_destination_bag_ids - untouchable_bag_ids
    movable_bags = [b for b in all_destination_bags if b.id in movable_bag_ids]
    return locked_packages, append_only_packages_for_algo, movable_bags

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class ProposePackingView(View):
    def get(self, request: HttpRequest):
        try:
            destination_id = int(request.GET.get("destination_id"))
        except (TypeError, ValueError):
            return _bad_request("destination_id は必須のクエリパラメータです。")
        destination = get_object_or_404(Destination, pk=destination_id)
        locked_packages, append_only_packages, movable_bags = _get_repack_assets(destination)
        max_weight = Decimal(str(getattr(settings, "PACKAGE_MAX_WEIGHT_KG", 25.0)))
        box_weight = Decimal(str(getattr(settings, "DEFAULT_BOX_WEIGHT_KG", 0.5)))
        calculated_packages = _pack_bags(movable_bags, max_weight, box_weight, existing_packages=append_only_packages)
        proposal_out = []
        for pkg in locked_packages:
            items = sorted([{"bag_id": i.bag.id, "product_name": i.bag.product.name, "weight_kg": float(i.bag.product.weight_kg)} for i in pkg.items.all()], key=lambda x: x['product_name'])
            proposal_out.append({"note": f"箱#{pkg.id} 維持 (ロック中)", "total_weight_kg": float(_pkg_weight_with_plans(pkg)), "items": items})
        new_box_counter = 0
        for pkg_group in calculated_packages:
            note = ""
            if pkg_group.get('id') is None:
                new_box_counter += 1
                note = f"新規作成 {new_box_counter}"
            else:
                new_bags_count = len({b.id for b in pkg_group['bags']} - pkg_group['initial_bag_ids'])
                note = f"箱#{pkg_group['id']} " + ("に追加" if new_bags_count > 0 else "は維持")
            items = sorted([{"bag_id": b.id, "product_name": b.product.name, "weight_kg": float(b.product.weight_kg)} for b in pkg_group['bags']], key=lambda x: x['product_name'])
            proposal_out.append({"note": note, "total_weight_kg": float(pkg_group['weight']), "items": items})
        if not proposal_out:
            return _ok({"proposal": [], "message": "再梱包の対象となる袋がありません。"})
        return _ok({"proposal": proposal_out})

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class ApplyPackingProposalView(View):
    @transaction.atomic
    def post(self, request: HttpRequest):
        data = _json(request)
        try:
            destination_id = int(data.get("destination_id"))
        except (TypeError, ValueError):
            return _bad_request("destination_id は整数で指定してください。")
        destination = get_object_or_404(Destination, pk=destination_id)
        _, append_only_packages, movable_bags = _get_repack_assets(destination)
        Package.objects.filter(destination=destination, lock_status=Package.LockStatus.UNLOCKED).delete()
        movable_bag_ids = {b.id for b in movable_bags}
        if movable_bag_ids:
            Allocation.objects.filter(bag_id__in=movable_bag_ids).delete()
        max_weight = Decimal(str(getattr(settings, "PACKAGE_MAX_WEIGHT_KG", 25.0)))
        box_weight = Decimal(str(getattr(settings, "DEFAULT_BOX_WEIGHT_KG", 0.5)))
        final_package_groups = _pack_bags(movable_bags, max_weight, box_weight, existing_packages=append_only_packages)
        created_count, updated_count = 0, 0
        for pkg_group in final_package_groups:
            if not pkg_group['bags']: continue
            for bag in pkg_group['bags']:
                if bag.id in movable_bag_ids:
                    demand_iter = _iter_order_items_with_demand(destination.id, bag.product_id)
                    try:
                        _, order_item_id = next(demand_iter)
                        Allocation.objects.create(order_item_id=order_item_id, bag=bag)
                    except StopIteration:
                        return _bad_request(f"商品「{bag.product.name}」の割当先注文が見つかりませんでした。")
            if pkg_group.get('id') is None:
                package = Package.objects.create(destination=destination, status=Package.PackageStatus.PACKAGING)
                PackageItem.objects.bulk_create([PackageItem(package=package, bag=bag) for bag in pkg_group['bags']])
                created_count += 1
            else:
                package = Package.objects.get(id=pkg_group['id'])
                new_bags = [b for b in pkg_group['bags'] if b.id not in pkg_group['initial_bag_ids']]
                if new_bags:
                    PackageItem.objects.bulk_create([PackageItem(package=package, bag=bag) for bag in new_bags])
                updated_count += 1
        return _ok({"message": "梱包を適用しました。", "packages_created": created_count, "packages_updated": updated_count})

def _get_global_repack_assets() -> Tuple[List[Dict], List[Bag], set[int]]:
    append_only_packages_for_algo = []
    untouchable_bag_ids = set()
    fixed_packages_qs = Package.objects.prefetch_related('items__bag__product__variety').filter(lock_status__in=[Package.LockStatus.LOCKED, Package.LockStatus.APPEND_ONLY])
    for pkg in fixed_packages_qs:
        current_bags = list(item.bag for item in pkg.items.all())
        untouchable_bag_ids.update(b.id for b in current_bags)
        if pkg.lock_status == Package.LockStatus.APPEND_ONLY:
            append_only_packages_for_algo.append({'id': pkg.id, 'bags': current_bags, 'weight': _pkg_weight_with_plans(pkg), 'variety_ids': {b.product.variety_id for b in current_bags}, 'initial_bag_ids': {b.id for b in current_bags}, 'destination_id': pkg.destination_id})
    movable_bags = list(Bag.objects.select_related('product__variety').filter(prepared=True).exclude(id__in=untouchable_bag_ids))
    movable_bag_ids = {b.id for b in movable_bags}
    return append_only_packages_for_algo, movable_bags, movable_bag_ids

def _pack_bags_globally(bags_with_dest: List[Bag], max_weight: Decimal, box_weight: Decimal, existing_packages: List[Dict]) -> Dict[int, List[Dict]]:
    bags_by_destination = defaultdict(list)
    for bag in bags_with_dest:
        dest_id = getattr(bag, 'temp_destination_id', None)
        if dest_id:
            bags_by_destination[dest_id].append(bag)
    existing_packages_by_destination = defaultdict(list)
    for pkg in existing_packages:
        existing_packages_by_destination[pkg['destination_id']].append(pkg)
    final_packages_by_destination = {}
    all_destination_ids = set(bags_by_destination.keys()) | set(existing_packages_by_destination.keys())
    for dest_id in all_destination_ids:
        dest_bags = sorted(bags_by_destination.get(dest_id, []), key=lambda b: b.id)
        dest_existing_pkgs = existing_packages_by_destination.get(dest_id, [])
        packed = _pack_bags(dest_bags, max_weight, box_weight, existing_packages=dest_existing_pkgs)
        if packed:
            final_packages_by_destination[dest_id] = packed
    return final_packages_by_destination

def _calculate_global_proposal(simulated: bool = True):
    with transaction.atomic():
        append_only_packages, movable_bags, movable_bag_ids = _get_global_repack_assets()
        total_demand_map = defaultdict(int)
        q_total_demand = (OrderItem.objects.filter(order__status=Order.OrderStatus.ACCEPTED).values('order__destination_id', 'product_id').annotate(total_qty=Sum('quantity')))
        for row in q_total_demand:
            key = (row['order__destination_id'], row['product_id'])
            total_demand_map[key] = row['total_qty']
        satisfied_by_fixed_map = defaultdict(int)
        fixed_bags_qs = Bag.objects.filter(packageitem__package__lock_status__in=[Package.LockStatus.LOCKED, Package.LockStatus.APPEND_ONLY]).select_related('product', 'packageitem__package__destination')
        for bag in fixed_bags_qs:
            key = (bag.packageitem.package.destination_id, bag.product_id)
            satisfied_by_fixed_map[key] += 1
        net_demand_map = defaultdict(int)
        for key, total_qty in total_demand_map.items():
            net_qty = total_qty - satisfied_by_fixed_map.get(key, 0)
            if net_qty > 0:
                net_demand_map[key] = net_qty
        flat_demand = []
        for (dest_id, prod_id), count in sorted(net_demand_map.items()):
            flat_demand.extend([(prod_id, dest_id)] * count)
        bags_by_product = defaultdict(list)
        for bag in sorted(movable_bags, key=lambda b: b.id):
            bags_by_product[bag.product_id].append(bag)
        bags_with_dest = []
        for prod_id, dest_id in flat_demand:
            if bags_by_product.get(prod_id):
                bag = bags_by_product[prod_id].pop(0)
                bag.temp_destination_id = dest_id
                bags_with_dest.append(bag)
        max_weight = Decimal(str(getattr(settings, "PACKAGE_MAX_WEIGHT_KG", 25.0)))
        box_weight = Decimal(str(getattr(settings, "DEFAULT_BOX_WEIGHT_KG", 0.5)))
        final_package_groups_by_dest = _pack_bags_globally(bags_with_dest, max_weight, box_weight, append_only_packages)
        if simulated:
            transaction.set_rollback(True)
            return final_package_groups_by_dest, movable_bag_ids
        Package.objects.filter(lock_status=Package.LockStatus.UNLOCKED).delete()
        if movable_bag_ids:
            Allocation.objects.filter(bag_id__in=movable_bag_ids).delete()
        order_item_q = (OrderItem.objects.filter(order__status=Order.OrderStatus.ACCEPTED).annotate(alloc_count=Count('allocations')).order_by('order__created_at', 'id'))
        order_item_pool = defaultdict(list)
        for item in order_item_q:
            remaining = item.quantity - item.alloc_count
            if remaining > 0:
                key = (item.order.destination_id, item.product_id)
                order_item_pool[key].extend([item.id] * remaining)
        created_count, updated_count = 0, 0
        for dest_id, pkg_groups in final_package_groups_by_dest.items():
            destination = get_object_or_404(Destination, pk=dest_id)
            for pkg_group in pkg_groups:
                if not pkg_group['bags']: continue
                for bag in pkg_group['bags']:
                    if bag.id in movable_bag_ids:
                        try:
                            key = (dest_id, bag.product_id)
                            order_item_id = order_item_pool[key].pop(0)
                            Allocation.objects.create(order_item_id=order_item_id, bag=bag)
                        except (KeyError, IndexError):
                            raise ValueError(f"商品「{bag.product.name}」の割当先注文(宛先:{dest_id})が見つかりませんでした。")
                if pkg_group.get('id') is None:
                    package = Package.objects.create(destination=destination, status=Package.PackageStatus.PACKAGING)
                    PackageItem.objects.bulk_create([PackageItem(package=package, bag=bag) for bag in pkg_group['bags']])
                    created_count += 1
                else:
                    package = get_object_or_404(Package, id=pkg_group['id'])
                    new_bags = [b for b in pkg_group['bags'] if b.id not in pkg_group['initial_bag_ids']]
                    if new_bags:
                        PackageItem.objects.bulk_create([PackageItem(package=package, bag=bag) for bag in new_bags])
                    updated_count += 1
        return created_count, updated_count

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class ProposeGlobalPackingView(View):
    def get(self, request: HttpRequest):
        try:
            final_package_groups_by_dest, _ = _calculate_global_proposal(simulated=True)
        except Exception as e:
            return _bad_request(f"提案の作成中にエラーが発生しました: {e}", code="calculation_error")
        proposal_by_dest_out = {}
        dest_cache = {d.id: d for d in Destination.objects.filter(id__in=final_package_groups_by_dest.keys())}
        for dest_id, calculated_packages in final_package_groups_by_dest.items():
            destination = dest_cache.get(dest_id)
            if not destination: continue
            locked_packages = Package.objects.filter(destination=destination, lock_status=Package.LockStatus.LOCKED)
            proposal_out = []
            for pkg in locked_packages:
                items = sorted([{"bag_id": i.bag.id, "product_name": i.bag.product.name, "weight_kg": float(i.bag.product.weight_kg)} for i in pkg.items.all()], key=lambda x: x['product_name'])
                proposal_out.append({"note": f"箱#{pkg.id} 維持 (ロック中)", "total_weight_kg": float(_pkg_weight_with_plans(pkg)), "items": items})
            new_box_counter = 0
            for pkg_group in calculated_packages:
                note = ""
                if pkg_group.get('id') is None:
                    new_box_counter += 1
                    note = f"新規作成 {new_box_counter}"
                else:
                    new_bags_count = len({b.id for b in pkg_group['bags']} - pkg_group.get('initial_bag_ids', set()))
                    note = f"箱#{pkg_group['id']} " + ("に追加" if new_bags_count > 0 else "は維持")
                items = sorted([{"bag_id": b.id, "product_name": b.product.name, "weight_kg": float(b.product.weight_kg)} for b in pkg_group['bags']], key=lambda x: x['product_name'])
                proposal_out.append({"note": note, "total_weight_kg": float(pkg_group['weight']), "items": items})
            if proposal_out:
                proposal_by_dest_out[str(dest_id)] = {"destination_name": destination.name, "proposal": proposal_out}
        if not proposal_by_dest_out:
            return _ok({"proposal_by_destination": {}, "message": "再梱包の対象となる袋がありません。"})
        return _ok({"proposal_by_destination": proposal_by_dest_out})

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class ApplyGlobalPackingProposalView(View):
    def post(self, request: HttpRequest):
        try:
            created_count, updated_count = _calculate_global_proposal(simulated=False)
            return _ok({"message": "一括梱包を適用しました。", "packages_created": created_count, "packages_updated": updated_count})
        except ValueError as e:
            return _bad_request(str(e), code="application_error")
        except Exception as e:
            return _bad_request(f"適用中に予期せぬエラーが発生しました: {e}", code="internal_error")
```


##### **ファイル:** `mg_workflow/api_shipping.py` **(新規作成)**
*   発送管理画面のデータ取得、CSVダウンロード、ステータス更新、伝票番号インポートのAPIを実装します。

```python
# mg_workflow/api_shipping.py
from django.http import JsonResponse, HttpRequest, HttpResponse
from django.views import View
from django.shortcuts import get_object_or_404
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_protect
from django.contrib.admin.views.decorators import staff_member_required
from django.utils import timezone
from django.db import transaction
import json
import csv
import io
import re
from collections import Counter

from orders.models import Package, Order
from system_settings.models import SystemSetting
from accounts.models import Destination

def _json(request: HttpRequest):
    try:
        body = request.body.decode("utf-8") or "{}"
        return json.loads(body)
    except json.JSONDecodeError:
        return {}

def _bad_request(message: str, *, code: str = "invalid_request"):
    return JsonResponse({"ok": False, "error": {"code": code, "message": message}}, status=400)

def _ok(data=None, *, status: int = 200):
    payload = {"ok": True}
    if data:
        payload.update(data)
    return JsonResponse(payload, status=status)

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class ShippingDataView(View):
    def get(self, request: HttpRequest):
        packages_qs = Package.objects.exclude(status=Package.PackageStatus.PACKAGING).select_related(
            'destination'
        ).prefetch_related(
            'items__bag__product__variety'
        ).order_by('destination__name', 'created_at')

        shipping_packages = []
        for pkg in packages_qs:
            item_names = [item.bag.product.name for item in pkg.items.all()]
            item_counts = Counter(item_names)
            summary_parts = [f"{name} x {count}" for name, count in sorted(item_counts.items())]
            items_summary = ", ".join(summary_parts)

            shipping_packages.append({
                "id": pkg.id,
                "label": pkg.label,
                "status": pkg.status,
                "status_display": pkg.get_status_display(),
                "items_summary": items_summary,
                "csv_exported_at": pkg.csv_exported_at.isoformat() if pkg.csv_exported_at else None,
                "tracking_number": pkg.tracking_number,
                "destination": {
                    "id": pkg.destination.id,
                    "name": pkg.destination.name,
                    "delivery_method": pkg.destination.delivery_method,
                }
            })
        
        return _ok({"shipping_packages": shipping_packages})

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageStatusUpdateView(View):
    def post(self, request: HttpRequest):
        data = _json(request)
        package_ids = data.get("package_ids", [])
        new_status = data.get("status")

        if not all([package_ids, new_status]):
            return _bad_request("package_ids and status are required.")
        if not isinstance(package_ids, list):
            return _bad_request("package_ids must be a list of integers.")

        valid_statuses = [s[0] for s in Package.PackageStatus.choices]
        if new_status not in valid_statuses:
            return _bad_request(f"Invalid status. Must be one of: {', '.join(valid_statuses)}")
        
        updated_count = 0
        with transaction.atomic():
            packages = Package.objects.select_for_update().filter(id__in=package_ids)
            
            if new_status == Package.PackageStatus.LABEL_PRINTED:
                target_packages = packages.filter(csv_exported_at__isnull=False)
                updated_count = target_packages.update(status=new_status, updated_at=timezone.now())
            else:
                updated_count = packages.update(status=new_status, updated_at=timezone.now())

        return _ok({
            "message": f"{updated_count}件のパッケージの状態を「{dict(Package.PackageStatus.choices)[new_status]}」に更新しました。",
            "updated_count": updated_count,
        })

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class ResetCsvExportStatusView(View):
    def post(self, request: HttpRequest):
        data = _json(request)
        package_ids = data.get("package_ids", [])
        if not package_ids or not isinstance(package_ids, list):
            return _bad_request("package_ids (リスト形式) は必須です。")

        with transaction.atomic():
            updated_count = Package.objects.filter(id__in=package_ids).update(csv_exported_at=None)

        return _ok({
            "message": f"{updated_count}件を「CSV出力前」に戻しました。",
            "updated_count": updated_count,
        })

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class DownloadB2CsvView(View):
    def post(self, request: HttpRequest):
        data = _json(request)
        package_ids = data.get("package_ids", [])
        if not package_ids:
            return _bad_request("package_idsは必須です。")

        try:
            settings_obj = SystemSetting.load()
        except SystemSetting.DoesNotExist:
            return _bad_request("システム設定（依頼主情報）が登録されていません。", code="no_settings")

        packages = Package.objects.filter(id__in=package_ids).select_related('destination').prefetch_related('items__bag__product__variety')
        
        output = io.StringIO()
        writer = csv.writer(output)
        
        header = ["お客様管理番号", "送り状種別", "クール区分", "伝票番号", "出荷予定日", "お届け予定日", "配達時間帯", "お届け先コード", "お届け先電話番号", "お届け先電話番号枝番", "お届け先郵便番号", "お届け先住所", "お届け先住所（アパート名等）", "お届け先会社・部門１", "お届け先会社・部門２", "お届け先名", "お届け先名（カナ）", "敬称", "ご依頼主コード", "ご依頼主電話番号", "ご依頼主電話番号枝番", "ご依頼主郵便番号", "ご依頼主住所", "ご依頼主住所（アパート名等）", "ご依頼主名", "ご依頼主名（カナ）", "品名コード１", "品名１", "品名コード２", "品名２", "荷扱い１", "荷扱い２", "記事", "コレクト代金引換額（税込）", "内消費税額等", "止置き", "営業所コード", "発行枚数", "個数口表示", "ご請求先顧客コード", "ご請求先分類コード", "運賃管理番号"]
        writer.writerow(header)

        for pkg in packages:
            dest = pkg.destination
            item_counts = Counter(item.bag.product for item in pkg.items.all())
            hinmei_parts = []
            for prod, count in sorted(item_counts.items(), key=lambda x: x[0].name):
                variety_name = prod.variety.name[:2]
                milling_char = '精' if prod.type == '精米' else '玄'
                weight_num = str(int(prod.weight_kg))
                hinmei_parts.append(f"{variety_name}{milling_char}{weight_num}x{count}")
            hinmei_full = ",".join(hinmei_parts)
            if len(hinmei_full) > 25: hinmei_full = hinmei_full[:24] + "…"
            addr1, addr2 = (dest.address[:50], dest.address[50:100]) if len(dest.address) > 50 else (dest.address, "")
            tel_edaban = str(dest.id) if dest.phone == settings_obj.shop_phone else ""
            user_id_fallback = ""
            try:
                first_order = Order.objects.filter(destination=dest, status=Order.OrderStatus.ACCEPTED).first()
                if first_order: user_id_fallback = first_order.user.id
            except: pass
            b2_code_raw = settings_obj.b2_customer_code or ""
            b2_customer_code_part, b2_fare_management_part = (b2_code_raw.split("-", 1) + [""])[:2] if "-" in b2_code_raw else (b2_code_raw, "")
            row = [f"PKG{pkg.id}", "0", "0", "", timezone.now().strftime('%Y/%m/%d'), "", "", dest.id, re.sub(r'\D', '', dest.phone or ""), tel_edaban, re.sub(r'\D', '', dest.postal_code or ""), addr1, addr2, "", "", dest.name, "", "様", "", re.sub(r'\D', '', settings_obj.shop_phone or ""), "", re.sub(r'\D', '', settings_obj.shop_postal_code or ""), settings_obj.shop_address or "", "", settings_obj.shop_name or "", "", "", hinmei_full, "", "", "", "", "", "", "", "0", "", "", "", b2_customer_code_part or user_id_fallback, "", b2_fare_management_part]
            writer.writerow(row)

        with transaction.atomic():
            packages.update(csv_exported_at=timezone.now())

        encoded_csv = output.getvalue().encode('cp932')
        filename = timezone.now().strftime('b2_export_%Y%m%d_%H%M%S.csv')
        response = HttpResponse(encoded_csv, content_type='text/csv; charset=Shift_JIS')
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        return response

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class ImportTrackingNumbersView(View):
    def post(self, request: HttpRequest):
        csv_file = request.FILES.get("csv_file")
        if not csv_file: return _bad_request("CSVファイルが提供されていません。")
        if not csv_file.name.lower().endswith('.csv'): return _bad_request("有効なCSVファイルをアップロードしてください。")
        try:
            decoded_file = csv_file.read().decode('cp932')
        except UnicodeDecodeError:
            return _bad_request("ファイルのデコードに失敗しました。文字コードがShift_JISであることを確認してください。")
        csv_reader = csv.reader(io.StringIO(decoded_file))
        try:
            next(csv_reader)
        except StopIteration:
            return _bad_request("CSVファイルが空か、ヘッダー行がありません。")
        updates, errors = {}, []
        for i, row in enumerate(csv_reader, start=2):
            if not row or len(row) < 4: continue
            pkg_id_raw, tracking_number = row[0], row[3]
            if not pkg_id_raw.upper().startswith('PKG') or not tracking_number.isdigit(): continue
            try:
                pkg_id = int(pkg_id_raw[3:])
                updates[pkg_id] = tracking_number
            except (ValueError, IndexError):
                errors.append(f"{i}行目: お客様管理番号 '{pkg_id_raw}' の形式が不正です。")
        if not updates:
            errors.append("CSVから有効な更新対象データが見つかりませんでした。")
            return _bad_request("CSVから有効な更新対象データが見つかりませんでした。")
        updated_count = 0
        with transaction.atomic():
            packages = Package.objects.select_for_update().filter(id__in=updates.keys())
            for pkg in packages:
                pkg.tracking_number = updates[pkg.id]
                pkg.save(update_fields=['tracking_number', 'updated_at'])
                updated_count += 1
        return _ok({"message": f"{updated_count}件の伝票番号を更新しました。", "updated_count": updated_count, "errors": errors})
```


##### **ファイル:** `mg_workflow/views.py` **(新規作成)**

* 袋詰、自動引当ボード、発送管理の各画面をレンダリングするためのビューを実装します。

```python
# mg_workflow/views.py
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required, user_passes_test
from django.db.models import Sum, Count
from django.db import transaction
from django.contrib import messages
from django.http import HttpResponsePermanentRedirect
from django.urls import reverse
import re
import json

from orders.models import Order, OrderItem, Bag
from products.models import Product

def is_staff_user(user):
    return user.is_staff

@login_required
@user_passes_test(is_staff_user, login_url='/accounts/login/')
def bagging_list_view(request):
    if request.method == 'POST':
        to_add = {}
        # (request.POSTから登録数量を解析するロジック...聖典ファイルよりそのまま移植)
        p_ids = request.POST.getlist('product_id') + request.POST.getlist('product_id[]')
        counts = request.POST.getlist('count') + request.POST.getlist('count[]')
        if p_ids and counts and len(p_ids) == len(counts):
            for pid_str, cnt_str in zip(p_ids, counts):
                try:
                    pid = int(pid_str)
                    cnt = int(cnt_str)
                    if pid > 0 and cnt > 0:
                        to_add[pid] = to_add.get(pid, 0) + cnt
                except ValueError:
                    continue
        if not to_add:
            for key, val in request.POST.items():
                m = re.match(r'^(?:quantity_done)_(\d+)$', key)
                if not m:
                    continue
                try:
                    pid = int(m.group(1))
                    cnt = int(val)
                    if pid > 0 and cnt > 0:
                        to_add[pid] = to_add.get(pid, 0) + cnt
                except ValueError:
                    continue
        
        if not to_add:
            messages.warning(request, "登録対象がありません。数量を入力してください。")
            return redirect('dashboard:mg_workflow:bagging_list')
        
        created_total, errors = 0, []
        with transaction.atomic():
            for pid, cnt in to_add.items():
                try:
                    product = Product.objects.get(id=pid)
                except Product.DoesNotExist:
                    errors.append(f"product_id={pid} が見つかりません。")
                    continue
                if cnt <= 0:
                    continue
                Bag.objects.bulk_create([Bag(product=product, prepared=True) for _ in range(cnt)], batch_size=500)
                created_total += cnt
        for msg in errors:
            messages.error(request, msg)
        if created_total > 0:
            messages.success(request, f"袋詰を {created_total} 袋 登録しました。")
        else:
            messages.info(request, "袋詰の登録は行われませんでした。")
        return redirect('dashboard:mg_workflow:bagging_list')

    required_qs = (OrderItem.objects.filter(order__status=Order.OrderStatus.ACCEPTED).values('product__id', 'product__name').annotate(req=Sum('quantity')))
    prepared_qs = (Bag.objects.filter(prepared=True).values('product__id').annotate(cnt=Count('id')))
    prepared_map = {row['product__id']: (row['cnt'] or 0) for row in prepared_qs}
    summary_list = []
    for row in required_qs:
        pid = row['product__id']
        name = row['product__name']
        req = row['req'] or 0
        done = prepared_map.get(pid, 0)
        remaining = max(0, req - done)
        if req > 0:
            summary_list.append({'product__name': name, 'product__pk': pid, 'remaining_quantity': remaining})
    
    context = {'bagging_summary': sorted(summary_list, key=lambda x: x['product__name'])}
    return render(request, 'mg_workflow/bagging_list.html', context)

@login_required
@user_passes_test(is_staff_user, login_url='/accounts/login/')
def packaging_board_view(request):
    context = {}
    return render(request, 'mg_workflow/packaging_board.html', context)

@login_required
@user_passes_test(is_staff_user, login_url='/accounts/login/')
def shipping_list_view(request):
    context = {}
    return render(request, 'mg_workflow/shipping_list.html', context)
```

##### **ファイル:** `mg_workflow/urls.py` **(新規作成)**

```python
# mg_workflow/urls.py
from django.urls import path
from . import views
from . import api_packaging
from . import api_shipping

app_name = 'mg_workflow'

urlpatterns = [
    path('bagging/', views.bagging_list_view, name='bagging_list'),
    path('packaging/', views.packaging_board_view, name='packaging_board'),
    path('shipping/', views.shipping_list_view, name='shipping_list'),

    # Packaging API
    path('api/packaging/package-items/', api_packaging.PackageItemCreateView.as_view(), name='api_package_items_create'),
    path('api/packaging/package-items/<int:package_item_id>/', api_packaging.PackageItemDeleteView.as_view(), name='api_package_items_delete'),
    path('api/packaging/package-items/<int:package_item_id>/move/', api_packaging.PackageItemMoveView.as_view(), name='api_package_items_move'),
    path('api/packaging/packages/', api_packaging.PackageCreateView.as_view(), name='api_packages_create'),
    path('api/packaging/packages/<int:package_id>/', api_packaging.PackageDeleteView.as_view(), name='api_packages_delete'),
    path('api/packaging/board-state/', api_packaging.BoardStateView.as_view(), name='api_packaging_board_state'),
    path('api/packaging/prepared-bags/', api_packaging.PreparedBagsView.as_view(), name='api_packaging_prepared_bags'),
    path('api/packaging/plan-items/', api_packaging.PlanItemUpsertView.as_view(), name='api_plan_items_upsert'),
    path('api/packaging/plan-items/consume/', api_packaging.PlanItemConsumeView.as_view(), name='api_plan_items_consume'),
    path('api/packaging/packages/<int:package_id>/label', api_packaging.PackageLabelUpdateView.as_view(), name='api_packages_label_update'),
    path('api/packaging/packages/<int:package_id>/lock-status/', api_packaging.PackageLockStatusUpdateView.as_view(), name='api_packages_lock_status_update'),
    path('api/packaging/allocatable-items/', api_packaging.AllocatableItemsView.as_view(), name='api_allocatable_items'),
    path('api/sidebar/stock-summary/', api_packaging.SidebarStockSummaryView.as_view(), name='api_sidebar_stock_summary'),
    path('api/packaging/propose-packing/', api_packaging.ProposePackingView.as_view(), name='api_propose_packing'),
    path('api/packaging/apply-packing-proposal/', api_packaging.ApplyPackingProposalView.as_view(), name='api_apply_packing_proposal'),
    path('api/packaging/propose-global-packing/', api_packaging.ProposeGlobalPackingView.as_view(), name='api_propose_global_packing'),
    path('api/packaging/apply-global-packing-proposal/', api_packaging.ApplyGlobalPackingProposalView.as_view(), name='api_apply_global_packing_proposal'),
    
    # Shipping API
    path('api/shipping/data/', api_shipping.ShippingDataView.as_view(), name='api_shipping_data'),
    path('api/shipping/packages/status/', api_shipping.PackageStatusUpdateView.as_view(), name='api_package_status_update'),
    path('api/shipping/download-b2-csv/', api_shipping.DownloadB2CsvView.as_view(), name='api_download_b2_csv'),
    path('api/shipping/packages/reset-csv-status/', api_shipping.ResetCsvExportStatusView.as_view(), name='api_reset_csv_status'),
    path('api/shipping/import-tracking-numbers/', api_shipping.ImportTrackingNumbersView.as_view(), name='api_import_tracking_numbers'),
]
```

#### 4. 手順3：プロジェクト全体へのURL組込み

`dashboard`アプリケーションのURL定義を修正し、新しく作成した`mg_workflow`アプリケーションへのルーティングを追加します。

##### **ファイル:** `dashboard/urls.py` **(全面的に上書き)**

```python
# dashboard/urls.py
from django.urls import path, include
from . import views

urlpatterns = [
    path('', views.dashboard_view, name='dashboard_top'),
    path('debug/', views.debug_view, name='debug_view'),
    path('import/', views.import_old_data_view, name='import'),
    path('manuals/', views.manual_management_view, name='manuals'),
    
    path('orders/', include('mg_orders.urls')),
    path('customers/', include('mg_customers.urls')),
    path('masters/', include('mg_masters.urls')),
    # ▼▼▼ 変更点: mg_workflowアプリケーションのURLをインクルード ▼▼▼
    path('workflow/', include('mg_workflow.urls')),
    # ▲▲▲ 変更点ここまで ▲▲▲

    path('api/manuals/<str:page_name>/', views.manual_content_view, name='api_manual_content'),
    path('api/csrf/', views.csrf_seed, name='api_csrf_seed'),
]
```


#### 5. 手順4：フロントエンドの実装 (`mg_workflow`アプリケーション)

出荷ワークフローの各画面に対応するテンプレートファイルとJavaScriptファイルを`mg_workflow`アプリケーション配下に新規作成します。

##### **ファイル:** `mg_workflow/templates/mg_workflow/bagging_list.html` **(新規作成)**

```html
{% extends "base_management.html" %}
{% load humanize %}
{% block title %}要袋詰リスト{% endblock %}

{% block content %}
<h1>要袋詰リスト</h1>
<p>袋詰めが必要な商品のリストです。物理作業が完了した**数量**を各欄に入力し、登録してください。</p>
<hr>

{% if bagging_summary %}
    <form action="{% url 'dashboard:mg_workflow:bagging_list' %}" method="post">
        {% csrf_token %}
        <div class="table-responsive">
            <table class="table table-striped table-bordered">
                <thead class="table-light">
                    <tr>
                        <th>商品名（品種・種類・容量）</th>
                        <th class="text-center" style="width: 20%;">残りの必要数量（袋）</th>
                        <th class="text-center" style="width: 20%;">今回完了した数量</th>
                    </tr>
                </thead>
                <tbody>
                    {% for item in bagging_summary %}
                    <tr>
                        <td class="align-middle"><strong>{{ item.product__name }}</strong></td>
                        <td class="text-center align-middle fs-5 fw-bold">{{ item.remaining_quantity }}</td>
                        <td class="text-center align-middle">
                            <input type="number" class="form-control form-control-lg text-center" 
                                   name="quantity_done_{{ item.product__pk }}" 
                                   value="0" min="0" max="{{ item.remaining_quantity }}">
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
        <div class="d-grid gap-2 mt-4">
            <button type="submit" class="btn btn-primary btn-lg" onclick="return confirm('入力した数量で袋詰完了を登録します。よろしいですか？');">入力した数量で完了登録する</button>
        </div>
    </form>
{% else %}
    <div class="alert alert-success" role="alert">
        現在、袋詰めが必要な商品はありません。
    </div>
{% endif %}

<a href="{% url 'dashboard:dashboard_top' %}" class="btn btn-secondary mt-3">&laquo; ダッシュボードに戻る</a>
{% endblock %}
```

##### **ファイル:** `mg_workflow/templates/mg_workflow/packaging_board.html` **(新規作成)**

```html
{% extends "base_management.html" %}
{% load static %}
{% block title %}自動引当・パッケージング提案ボード{% endblock %}

{% block extra_css %}
<style>
#api-board-root { min-height: 500px; }
.destination-card { min-height: 200px; }
.package-card { min-width: 320px; max-width: 320px; display: flex; flex-direction: column; }
.package-card .card-body { flex-grow: 1; }
.dd-list { min-height: 80px; list-style-type: none; padding: 0; }
.dd-item { padding: 0.3rem 0.5rem; border: 1px solid #ddd; background-color: #fff; margin-bottom: 4px; border-radius: 0.25rem; cursor: grab; }
.dd-item.is-planned { background-color: #e9ecef; border-style: dashed; }
.dd-item:active { cursor: grabbing; }
#floating-status-panel { position: fixed; bottom: 20px; right: 20px; width: 350px; max-width: 90vw; background-color: rgba(255, 255, 255, 0.95); backdrop-filter: blur(5px); border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1050; transition: all 0.3s ease-in-out; }
#floating-status-panel .summary-view { padding: 0.75rem 1rem; font-size: 0.9rem; display: flex; flex-wrap: wrap; gap: 0.5rem 1rem; align-items: center; }
#floating-status-panel .detail-view { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-in-out; border-top: 1px solid #eee; padding: 0 1rem; }
#floating-status-panel.is-expanded .detail-view { max-height: 400px; overflow-y: auto; padding: 1rem; }
.toggle-details { cursor: pointer; }
.detail-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 0.5rem; font-size: 0.8rem; }
.detail-grid-item { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
</style>
{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-3"><h1 class="mb-0">自動引当・パッケージング提案ボード</h1></div>
<div id="floating-status-panel"><div class="summary-view"></div><div class="detail-view"></div></div>
<div class="row g-2 mb-3 align-items-center">
    <div class="col-md-4"><input type="text" id="filter-destination" class="form-control" placeholder="宛先名で絞り込み..."></div>
    <div class="col-md-auto"><button type="button" class="btn btn-primary" id="global-proposal-btn"><i class="bi bi-box-seam"></i> 一括自動梱包</button></div>
    <div class="col"><div class="row g-2"><div class="col-sm"><select id="filter-variety" class="form-select form-select-sm"><option value="">すべての品種</option></select></div><div class="col-sm"><select id="filter-milling" class="form-select form-select-sm"><option value="">精米/玄米</option></select></div><div class="col-sm"><select id="filter-weight" class="form-select form-select-sm"><option value="">すべての重量</option></select></div></div></div>
</div>
<div id="api-board-root"><div class="alert alert-secondary">読込中...</div></div>
<div class="modal fade" id="addBagModal" tabindex="-1"><div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">箱に袋を追加</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"></div><div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button><button type="button" class="btn btn-primary" id="addBagSaveBtn">この内容で追加する</button></div></div></div></div>
<div class="modal fade" id="addPlanModal" tabindex="-1"><div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">箱に予約を追加</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"></div><div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button><button type="button" class="btn btn-primary" id="addPlanSaveBtn">この内容で予約する</button></div></div></div></div>
<div class="modal fade" id="proposalModal" tabindex="-1"><div class="modal-dialog modal-xl modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="proposalModalLabel">自動梱包提案</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"></div><div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button><button type="button" class="btn btn-primary" id="proposalApplyBtn">この内容で確定する</button></div></div></div></div>
<div class="modal fade" id="globalProposalModal" tabindex="-1"><div class="modal-dialog modal-xl modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="globalProposalModalLabel">一括自動梱包提案</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"></div><div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button><button type="button" class="btn btn-primary" id="globalProposalApplyBtn">この内容で確定する</button></div></div></div></div>
<div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100"><div id="appToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true"><div class="toast-header"><strong class="me-auto" id="appToastTitle">通知</strong><button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button></div><div class="toast-body" id="appToastBody"></div></div></div>
{% endblock %}

{% block extra_js %}
    <script src="{% static 'mg_workflow/js/packaging_board.js' %}"></script>
{% endblock %}
```

##### **ファイル:** `mg_workflow/templates/mg_workflow/shipping_list.html` **(新規作成)**

```html
{% extends "base_management.html" %}
{% load static %}
{% block title %}発送管理{% endblock %}
{% block extra_css %}<style>.destination-group-row { background-color: #f8f9fa; font-weight: bold; } .package-row td { vertical-align: middle; } .package-row-item { padding-left: 2.5rem !important; } .package-row.is-exported { background-color: #fffbe6; }</style>{% endblock %}
{% block content %}
<div class="d-flex justify-content-between align-items-center mb-3">
  <h1 class="mb-0">発送管理</h1>
  <div id="global-actions-container" class="d-flex align-items-center gap-2">
    <form id="tracking-number-import-form" class="d-inline-block"><input type="file" id="csv-file-input" class="d-none" accept=".csv,text/csv"><button type="button" id="import-csv-btn" class="btn btn-outline-success"><i class="bi bi-file-earmark-arrow-up"></i> 伝票番号CSV取込</button></form>
  </div>
</div>
<div class="card mb-3"><div class="card-body">
    <div id="bulk-actions-ready" class="bulk-actions-panel"><div class="d-flex flex-wrap align-items-center gap-2"><div class="btn-group btn-group-sm me-3" role="group"><button type="button" class="btn btn-outline-secondary" id="filter-select-unexported">CSV出力前のみ</button><button type="button" class="btn btn-outline-secondary" id="filter-select-exported">CSV出力済のみ</button><button type="button" class="btn btn-outline-secondary" id="filter-select-all">すべて選択</button><button type="button" class="btn btn-outline-secondary" id="filter-select-none">選択解除</button></div><div class="d-flex align-items-center gap-2" id="bulk-execution-controls-ready"><span class="fw-bold text-muted me-2"><span class="selected-count">0</span> 件選択中:</span><button class="btn btn-sm btn-primary" id="bulk-csv-export-btn"><i class="bi bi-printer"></i> CSV出力</button><button class="btn btn-sm btn-info" id="bulk-mark-as-printed-btn"><i class="bi bi-check2-circle"></i> 伝票印刷済みにする</button><button class="btn btn-sm btn-outline-secondary" id="bulk-reset-csv-status-btn"><i class="bi bi-arrow-counterclockwise"></i> CSV出力前に戻す</button><button class="btn btn-sm btn-outline-danger" id="bulk-revert-to-packaging-btn"><i class="bi bi-arrow-return-left"></i> 梱包へ戻す</button></div></div></div>
    <div id="bulk-actions-printed" class="bulk-actions-panel d-none"><div class="d-flex flex-wrap align-items-center gap-2"><div class="btn-group btn-group-sm me-3" role="group"><button type="button" class="btn btn-outline-secondary" id="printed-select-all">すべて選択</button><button type="button" class="btn btn-outline-secondary" id="printed-select-none">選択解除</button></div><div class="d-flex align-items-center gap-2" id="bulk-execution-controls-printed"><span class="fw-bold text-muted me-2"><span class="selected-count">0</span> 件選択中:</span><button class="btn btn-sm btn-success" id="bulk-mark-as-shipped-btn"><i class="bi bi-truck"></i> 発送済みにする</button><button class="btn btn-sm btn-outline-danger" id="bulk-revert-to-ready-btn"><i class="bi bi-arrow-return-left"></i> 発送準備完了に戻す</button></div></div></div>
    <div id="bulk-actions-done" class="bulk-actions-panel d-none"><div class="d-flex flex-wrap align-items-center gap-2"><div class="btn-group btn-group-sm me-3" role="group"><button type="button" class="btn btn-outline-secondary" id="done-select-all">すべて選択</button><button type="button" class="btn btn-outline-secondary" id="done-select-none">選択解除</button></div><div class="d-flex align-items-center gap-2" id="bulk-execution-controls-done"><span class="fw-bold text-muted me-2"><span class="selected-count">0</span> 件選択中:</span><button class="btn btn-sm btn-outline-danger" id="bulk-revert-to-printed-btn"><i class="bi bi-arrow-return-left"></i> 伝票印刷済みに戻す (発送済み対象)</button><button class="btn btn-sm btn-outline-danger" id="bulk-revert-to-ready-from-done-btn"><i class="bi bi-arrow-return-left"></i> 発送準備完了に戻す (手渡し対象)</button></div></div></div>
</div></div>
<ul class="nav nav-tabs mb-3" id="shippingTab" role="tablist">
  <li class="nav-item" role="presentation"><button class="nav-link active" id="ready-tab" data-bs-toggle="tab" data-bs-target="#ready-panel" type="button" role="tab">発送準備完了 <span class="badge bg-secondary" data-count-ready>0</span></button></li>
  <li class="nav-item" role="presentation"><button class="nav-link" id="printed-tab" data-bs-toggle="tab" data-bs-target="#printed-panel" type="button" role="tab">伝票印刷済み <span class="badge bg-secondary" data-count-printed>0</span></button></li>
  <li class="nav-item" role="presentation"><button class="nav-link" id="done-tab" data-bs-toggle="tab" data-bs-target="#done-panel" type="button" role="tab">完了済み <span class="badge bg-secondary" data-count-done>0</span></button></li>
</ul>
<div class="tab-content" id="shippingTabContent">
  <div class="tab-pane fade show active" id="ready-panel" role="tabpanel"><table class="table table-hover"><thead><tr><th style="width: 5%"></th><th style="width: 20%">宛先 / 箱ID</th><th>中身</th><th style="width: 15%">伝票番号</th><th style="width: 15%">ステータス</th><th style="width: 25%">個別操作</th></tr></thead><tbody data-tbody-ready></tbody></table><div class="alert alert-info d-none" data-empty-ready>対象の荷物はありません。</div></div>
  <div class="tab-pane fade" id="printed-panel" role="tabpanel"><table class="table table-hover"><thead><tr><th style="width: 5%"></th><th style="width: 20%">宛先 / 箱ID</th><th>中身</th><th style="width: 15%">伝票番号</th><th style="width: 15%">ステータス</th><th style="width: 25%">個別操作</th></tr></thead><tbody data-tbody-printed></tbody></table><div class="alert alert-info d-none" data-empty-printed>対象の荷物はありません。</div></div>
  <div class="tab-pane fade" id="done-panel" role="tabpanel"><table class="table table-hover"><thead><tr><th style="width: 5%"></th><th style="width: 20%">宛先 / 箱ID</th><th>中身</th><th style="width: 15%">伝票番号</th><th style="width: 15%">ステータス</th><th style="width: 25%">個別操作</th></tr></thead><tbody data-tbody-done></tbody></table><div class="alert alert-info d-none" data-empty-done>対象の荷物はありません。</div></div>
</div>
<div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100"><div id="appToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true"><div class="toast-header"><strong id="appToastTitle" class="me-auto">通知</strong><button type="button" class="btn-close" data-bs-dismiss="toast"></button></div><div id="appToastBody" class="toast-body">メッセージ</div></div></div>
{% endblock %}

{% block extra_js %}
  <script src="{% static 'mg_workflow/js/shipping_list.js' %}"></script>
{% endblock %}
```


##### **ファイル:** `mg_workflow/static/mg_workflow/js/packaging_board.js` **(新規作成)**

* `static` ディレクトリの下に `mg_workflow/js` というディレクトリを作成し、そこに保存してください。

```javascript
// mg_workflow/static/mg_workflow/js/packaging_board.js
(() => {
  const BASE = "/management/workflow/api";
  const $root = () => document.getElementById("api-board-root");
  let createdAutoBoxes = false;
  let appToastInstance = null;
  
  function ready(fn){ document.readyState!=='loading' ? fn() : document.addEventListener('DOMContentLoaded', fn); }
  function qs(sel, el=document){ return el.querySelector(sel); }
  function qsa(sel, el=document){ return Array.from(el.querySelectorAll(sel)); }
  function h(tag, props={}, ...children){
    const el = document.createElement(tag);
    Object.entries(props||{}).forEach(([k,v])=>{
      if (k==='class') el.className = v; else if (k.startsWith('data-')) el.setAttribute(k, v); else if (k==='text') el.textContent = v; else el[k] = v;
    });
    for (const c of children) el.append(c);
    return el;
  }
  function getCookie(name){
    const m = (`; ${document.cookie}`).split(`; ${name}=`).pop();
    return m ? m.split(';')[0] : '';
  }
  async function api(path, {method='GET', json, headers}={}){
    const hds = Object.assign({'X-CSRFToken': getCookie('csrftoken')}, headers||{});
    let body;
    if (json!==undefined){ hds['Content-Type']='application/json'; body=JSON.stringify(json); }
    const res = await fetch(path, {method, headers:hds, body});
    let data = null;
    const responseText = await res.text();
    try { data = responseText ? JSON.parse(responseText) : null; } catch(e) {}
    return {ok: res.ok, status: res.status, data, text: responseText};
  }

  function initializeToast() {
    const toastEl = document.getElementById('appToast');
    if (toastEl) {
      appToastInstance = new bootstrap.Toast(toastEl, { delay: 4000 });
    }
  }

  function toast(msg, type='danger'){
    if (!appToastInstance) {
      alert(msg);
      return;
    }
    const toastEl = appToastInstance._element;
    const toastHeader = qs('.toast-header', toastEl);
    const toastTitle = qs('#appToastTitle', toastEl);
    const toastBody = qs('#appToastBody', toastEl);
    
    toastBody.textContent = msg;
    
    toastHeader.classList.remove('bg-success', 'bg-danger', 'text-white');
    if (type === 'success') {
      toastTitle.textContent = '成功';
      toastHeader.classList.add('bg-success', 'text-white');
    } else {
      toastTitle.textContent = 'エラー';
      toastHeader.classList.add('bg-danger', 'text-white');
    }

    appToastInstance.show();
  }

  function initializeTooltips() {
    const tooltipTriggerList = qsa('[data-bs-toggle="tooltip"]');
    tooltipTriggerList.forEach(tooltipTriggerEl => {
      const tooltip = bootstrap.Tooltip.getInstance(tooltipTriggerEl);
      if (tooltip) {
        tooltip.dispose();
      }
    });
    document.querySelectorAll('.tooltip').forEach(tip => tip.remove());
    tooltipTriggerList.forEach(tooltipTriggerEl => {
      new bootstrap.Tooltip(tooltipTriggerEl);
    });
  }
  
  async function updateLockStatus(packageId, currentStatus) {
    const statusOrder = ['UNLOCKED', 'APPEND_ONLY', 'LOCKED'];
    const currentIndex = statusOrder.indexOf(currentStatus);
    const nextStatus = statusOrder[(currentIndex + 1) % statusOrder.length];

    const res = await api(`${BASE}/packaging/packages/${packageId}/lock-status/`, {
        method: 'PATCH',
        json: { lock_status: nextStatus }
    });

    if (!res.ok) {
        toast(res.data?.error?.message || `ロック状態の更新に失敗しました: ${res.status}`);
    }
    await reloadBoard();
  }

  async function updatePackageStatus(packageId, newStatus) {
    const res = await api(`${BASE}/shipping/packages/status/`, {
      method: 'POST',
      json: { package_ids: [packageId], status: newStatus }
    });
    if (res.ok) {
        toast(res.data?.message || `箱の状態を更新しました。`, 'success');
        await reloadBoard();
    } else {
        toast(res.data?.error?.message || '箱の状態更新に失敗しました。');
    }
  }

  async function updateSidebarSummary() {
    const summaryTableBody = document.querySelector('.sidebar .table tbody');
    if (!summaryTableBody) return;
    const res = await api('/management/workflow/api/sidebar/stock-summary/');
    if (!res.ok || !res.data?.bag_stock_summary) { console.error('Failed to fetch sidebar summary'); return; }
    const summaryData = res.data.bag_stock_summary;
    summaryTableBody.innerHTML = '';
    for (const item of summaryData) {
      const row = h('tr');
      row.innerHTML = `<td>${item.name}</td><td class="text-center">${item.total}</td><td class="text-center text-danger fw-bold">${item.unbagged}</td><td class="text-center">${item.bag_rice}</td><td class="text-center">${item.boxed}</td>`;
      summaryTableBody.append(row);
    }
  }

  function renderStatusPanel(preparedGroups) {
    const panel = qs('#floating-status-panel');
    if (!panel) return;
    const summaryView = qs('.summary-view', panel);
    const detailView = qs('.detail-view', panel);
    const summaryByVariety = {};
    for (const item of preparedGroups) {
      const varietyName = item.product_name.split(' ')[0] || '不明';
      if (!summaryByVariety[varietyName]) {
        summaryByVariety[varietyName] = { types: 0, totalQty: 0 };
      }
      if (item.qty > 0) {
        summaryByVariety[varietyName].types += 1;
        summaryByVariety[varietyName].totalQty += item.qty;
      }
    }
    summaryView.innerHTML = '';
    summaryView.append(h('strong', { class:'small', text: '【未引当 在庫】' }));
    for (const [variety, data] of Object.entries(summaryByVariety)) {
      const text = `${variety}: ${data.types}種 / ${data.totalQty}袋`;
      summaryView.append(h('span', {}, text));
    }
    const toggleBtn = h('span', { class: 'badge bg-secondary-subtle text-secondary-emphasis rounded-pill toggle-details' });
    toggleBtn.innerHTML = '詳細表示 ▼';
    summaryView.append(toggleBtn);
    detailView.innerHTML = '';
    const gridContainer = h('div', { class: 'detail-grid' });
    const sortedGroups = [...preparedGroups].sort((a, b) => a.product_name.localeCompare(b.product_name));
    for (const item of sortedGroups) {
      if(item.qty > 0) {
        const itemEl = h('div', { class: 'detail-grid-item' }, h('span', { class: 'name', text: item.product_name }), h('span', { class: 'float-end' }, h('span', { class: 'qty', text: item.qty }), h('span', { class: 'small text-muted' }, ' 袋')));
        gridContainer.append(itemEl);
      }
    }
    detailView.append(gridContainer);
    toggleBtn.onclick = () => {
      panel.classList.toggle('is-expanded');
      toggleBtn.innerHTML = panel.classList.contains('is-expanded') ? '閉じる ▲' : '詳細表示 ▼';
    };
  }

  async function openAddBagModal(packageId, destinationId, destinationName) {
    qsa('[data-bs-toggle="tooltip"]').forEach(el => bootstrap.Tooltip.getInstance(el)?.hide());
    const modal = qs('#addBagModal');
    if (!modal) return toast('モーダル要素が見つかりません。');
    qs('.modal-title', modal).textContent = `箱 #${packageId} (${destinationName} 様) に袋を追加`;
    const body = qs('.modal-body', modal);
    body.innerHTML = '<div class="text-center p-4">読み込み中...</div>';
    const saveBtn = qs('#addBagSaveBtn', modal);
    saveBtn.dataset.packageId = packageId;
    saveBtn.dataset.destinationId = destinationId;
    const modalInstance = new bootstrap.Modal(modal);
    modalInstance.show();
    const res = await api(`${BASE}/packaging/allocatable-items/?destination_id=${destinationId}`);
    if (!res.ok || !res.data?.allocatable_items) {
      body.innerHTML = '<div class="alert alert-danger">追加可能な袋のリストを取得できませんでした。</div>';
      return;
    }
    renderAddBagModalContent(res.data.allocatable_items, body);
  }

  function renderAddBagModalContent(items, modalBody) {
    modalBody.innerHTML = '';
    const addableItems = items.filter(item => Math.min(item.remaining_demand, item.available_stock) > 0);
    if (addableItems.length === 0) {
      modalBody.innerHTML = '<div class="text-center text-muted p-4">この宛先に追加できる準備済みの袋はありません。</div>';
      return;
    }
    const form = h('form');
    for (const item of addableItems) {
      const maxAddable = Math.min(item.remaining_demand, item.available_stock);
      const group = h('div', { class: 'row mb-3 align-items-center' });
      const label = h('label', { class: 'col-sm-7 col-form-label' }, h('span', { text: item.product_name }), h('small', { class: 'd-block text-muted', text: `(注文残: ${item.remaining_demand} | 在庫: ${item.available_stock})` }));
      const inputWrapper = h('div', { class: 'col-sm-5' });
      const input = h('input', { type: 'number', class: 'form-control', 'data-product-id': item.product_id, min: 0, max: maxAddable, placeholder: '0' });
      inputWrapper.append(input);
      group.append(label, inputWrapper);
      form.append(group);
    }
    modalBody.append(form);
  }

  function setupModalSaveButton() {
    const saveBtn = qs('#addBagSaveBtn');
    if (!saveBtn) return;
    saveBtn.onclick = async (evt) => {
      const btn = evt.currentTarget;
      const { packageId, destinationId } = btn.dataset;
      const modal = btn.closest('.modal');
      const inputs = qsa('input[type="number"]', modal);
      btn.disabled = true;
      btn.textContent = '追加処理中...';
      const requests = [];
      for (const input of inputs) {
        const count = parseInt(input.value, 10);
        if (count > 0) {
          requests.push(api(`${BASE}/packaging/package-items/`, { method: 'POST', json: { package_id: parseInt(packageId, 10), destination_id: parseInt(destinationId, 10), product_id: parseInt(input.dataset.productId, 10), count: count } }));
        }
      }
      try {
        if (requests.length > 0) {
            const results = await Promise.all(requests);
            const firstError = results.find(res => !res.ok);
            if (firstError) {
                toast(firstError.data?.error?.message || '一部の袋の追加に失敗しました。ページを再読み込みします。', 'danger');
            }
        }
        bootstrap.Modal.getInstance(modal)?.hide();
        await reloadBoard();
      } catch (err) {
        toast('袋の追加中に予期せぬエラーが発生しました。', 'danger');
      } finally {
        btn.disabled = false;
        btn.textContent = 'この内容で追加する';
      }
    };
  }
  async function openAddPlanModal(pkg, destinationId, destinationName) {
    qsa('[data-bs-toggle="tooltip"]').forEach(el => bootstrap.Tooltip.getInstance(el)?.hide());
    const modal = qs('#addPlanModal');
    if (!modal) return toast('予約モーダル要素が見つかりません。');
    qs('.modal-title', modal).textContent = `箱 #${pkg.id} (${destinationName} 様) に予約を追加`;
    const body = qs('.modal-body', modal);
    body.innerHTML = '<div class="text-center p-4">読み込み中...</div>';
    const saveBtn = qs('#addPlanSaveBtn', modal);
    saveBtn.dataset.packageId = pkg.id;
    saveBtn.dataset.destinationId = destinationId;
    const modalInstance = new bootstrap.Modal(modal);
    modalInstance.show();
    const res = await api(`${BASE}/packaging/allocatable-items/?destination_id=${destinationId}`);
    if (!res.ok || !res.data?.allocatable_items) {
      body.innerHTML = '<div class="alert alert-danger">予約可能な商品のリストを取得できませんでした。</div>';
      return;
    }
    renderAddPlanModalContent(res.data.allocatable_items, body, pkg);
  }

  function renderAddPlanModalContent(items, modalBody, pkg) {
    modalBody.innerHTML = '';
    const addableItems = items.filter(item => item.remaining_demand > 0);
    if (addableItems.length === 0) {
      modalBody.innerHTML = '<div class="text-center text-muted p-4">この宛先で予約できる商品はありません。</div>';
      return;
    }
    const availableWeight = (pkg.max_weight_kg || 0) - (pkg.current_weight_kg || 0);
    const form = h('form');
    for (const item of addableItems) {
      const itemWeight = item.weight_kg || 0;
      const maxAddableByWeight = itemWeight > 0 ? Math.floor(availableWeight / itemWeight) : Infinity;
      const maxAddable = Math.min(item.remaining_demand, maxAddableByWeight);
      const group = h('div', { class: 'row mb-3 align-items-center' });
      let helpText = `(注文残: ${item.remaining_demand})`;
      if (maxAddable < item.remaining_demand) {
        helpText += ` | 重量上限: ${maxAddable}個まで`;
      }
      const label = h('label', { class: 'col-sm-7 col-form-label' }, h('span', { text: item.product_name }), h('small', { class: 'd-block text-muted', text: helpText }));
      const inputWrapper = h('div', { class: 'col-sm-5' });
      const currentPlanQty = (pkg.plans || []).find(p => p.product_id === item.product_id)?.quantity || 0;
      const input = h('input', { type: 'number', class: 'form-control', 'data-product-id': item.product_id, 'data-current-qty': currentPlanQty, min: 0, max: maxAddable, placeholder: '0' });
      if (maxAddable <= 0) {
        input.disabled = true;
        label.querySelector('small').textContent += ' (追加不可)';
        label.classList.add('text-muted');
      }
      inputWrapper.append(input);
      group.append(label, inputWrapper);
      form.append(group);
    }
    modalBody.append(form);
  }
  
  function setupPlanModalSaveButton() {
    const saveBtn = qs('#addPlanSaveBtn');
    if (!saveBtn) return;
    saveBtn.onclick = async (evt) => {
      const btn = evt.currentTarget;
      const { packageId } = btn.dataset;
      const modal = btn.closest('.modal');
      const inputs = qsa('input[type="number"]:not(:disabled)', modal);
      btn.disabled = true;
      btn.textContent = '予約処理中...';
      const requests = [];
      for (const input of inputs) {
        const quantityToAdd = parseInt(input.value, 10);
        if (quantityToAdd > 0) {
          const currentQty = parseInt(input.dataset.currentQty, 10) || 0;
          const newTotalQty = currentQty + quantityToAdd;
          requests.push(api(`${BASE}/packaging/plan-items/`, { method: 'POST', json: { package_id: parseInt(packageId, 10), product_id: parseInt(input.dataset.productId, 10), quantity: newTotalQty } }));
        }
      }
      try {
        if (requests.length > 0) {
            const results = await Promise.all(requests);
            const firstError = results.find(res => !res.ok);
            if (firstError) {
                toast(firstError.data?.error?.message || '一部の予約に失敗しました。ページを再読み込みします。', 'danger');
            }
        }
        bootstrap.Modal.getInstance(modal)?.hide();
        await reloadBoard();
      } catch (err) {
        toast('予約中に予期せぬエラーが発生しました。', 'danger');
      } finally {
        btn.disabled = false;
        btn.textContent = 'この内容で予約する';
      }
    };
  }

  async function openProposalModal(destinationId, destinationName) {
    qsa('[data-bs-toggle="tooltip"]').forEach(el => bootstrap.Tooltip.getInstance(el)?.hide());
    const modal = qs('#proposalModal');
    if (!modal) return toast('提案モーダル要素が見つかりません。');
    qs('.modal-title', modal).textContent = `${destinationName} 様 自動梱包提案`;
    const body = qs('.modal-body', modal);
    body.innerHTML = '<div class="text-center p-4">提案を作成中...</div>';
    const applyBtn = qs('#proposalApplyBtn', modal);
    applyBtn.dataset.destinationId = destinationId;
    
    const modalInstance = new bootstrap.Modal(modal);
    modalInstance.show();

    const res = await api(`${BASE}/packaging/propose-packing/?destination_id=${destinationId}`);
    if (!res.ok || !res.data) {
        body.innerHTML = `<div class="alert alert-danger">提案の作成に失敗しました: ${res.data?.error?.message || res.status}</div>`;
        return;
    }

    renderProposalModalContent(res.data, body);
  }

  function renderProposalModalContent(data, modalBody) {
    modalBody.innerHTML = '';
    const { proposal } = data;
    if (!proposal || proposal.length === 0) {
        modalBody.innerHTML = `<div class="alert alert-info">${data.message || 'この宛先には自動梱包の対象となる未梱包の袋がありません。'}</div>`;
        qs('#proposalApplyBtn').style.display = 'none';
        return;
    }
    qs('#proposalApplyBtn').style.display = 'inline-block';
    
    const container = h('div', { class: 'row' });
    proposal.forEach((pkg, index) => {
        const col = h('div', { class: 'col-md-6 col-lg-4 mb-3' });
        const card = h('div', { class: 'card h-100' });
        
        let headerClass = 'card-header';
        if (pkg.note.includes('ロック中')) {
            headerClass += ' bg-secondary-subtle';
        } else if (pkg.note.includes('維持')) {
            headerClass += ' bg-light';
        }

        const cardHeader = h('div', { class: headerClass },
            h('strong', { text: `箱 ${index + 1}` }),
            pkg.note ? h('span', { class: 'badge bg-info-subtle text-info-emphasis rounded-pill ms-2', text: pkg.note }) : '',
            h('small', { class: 'text-muted float-end', text: `総重量: ${pkg.total_weight_kg.toFixed(2)} kg` })
        );
        const listGroup = h('ul', { class: 'list-group list-group-flush' });
        pkg.items.forEach(item => {
            const li = h('li', { class: 'list-group-item small' },
                h('span', { class: 'd-block', text: `袋#${item.bag_id}: ${item.product_name}` })
            );
            listGroup.append(li);
        });
        card.append(cardHeader, listGroup);
        col.append(card);
        container.append(col);
    });
    modalBody.append(container);
  }

  function setupProposalModalSaveButton() {
    const applyBtn = qs('#proposalApplyBtn');
    if (!applyBtn) return;
    applyBtn.onclick = async (evt) => {
        const btn = evt.currentTarget;
        const { destinationId } = btn.dataset;
        const modal = btn.closest('.modal');

        btn.disabled = true;
        btn.textContent = '確定処理中...';

        const res = await api(`${BASE}/packaging/apply-packing-proposal/`, {
            method: 'POST',
            json: { destination_id: parseInt(destinationId, 10) }
        });

        bootstrap.Modal.getInstance(modal)?.hide();

        if (res.ok) {
            toast(res.data?.message || '自動梱包を適用しました。', 'success');
            await reloadBoard();
        } else {
            toast(res.data?.error?.message || '提案の適用に失敗しました。', 'danger');
        }

        btn.disabled = false;
        btn.textContent = 'この内容で確定する';
    };
  }
  async function openGlobalProposalModal() {
    qsa('[data-bs-toggle="tooltip"]').forEach(el => bootstrap.Tooltip.getInstance(el)?.hide());
    const modal = qs('#globalProposalModal');
    if (!modal) return toast('提案モーダル要素が見つかりません。');
    qs('.modal-title', modal).textContent = '一括自動梱包提案';
    const body = qs('.modal-body', modal);
    body.innerHTML = '<div class="text-center p-4">提案を作成中... (この処理には時間がかかる場合があります)</div>';
    
    const modalInstance = new bootstrap.Modal(modal);
    modalInstance.show();

    const res = await api(`${BASE}/packaging/propose-global-packing/`);
    if (!res.ok || !res.data) {
        body.innerHTML = `<div class="alert alert-danger">提案の作成に失敗しました: ${res.data?.error?.message || res.status}</div>`;
        return;
    }
    
    renderGlobalProposalModalContent(res.data, body);
  }

  function renderGlobalProposalModalContent(data, modalBody) {
      modalBody.innerHTML = '';
      const { proposal_by_destination } = data;
      const proposalEntries = Object.entries(proposal_by_destination || {});

      if (proposalEntries.length === 0) {
          modalBody.innerHTML = `<div class="alert alert-info">${data.message || '梱包対象の袋や宛先がありません。'}</div>`;
          qs('#globalProposalApplyBtn').style.display = 'none';
          return;
      }
      qs('#globalProposalApplyBtn').style.display = 'inline-block';
      
      const accordion = h('div', { class: 'accordion', id: 'globalProposalAccordion' });

      proposalEntries.forEach(([destId, destData], index) => {
          const { destination_name, proposal } = destData;

          const accordionItem = h('div', { class: 'accordion-item' });
          const accordionHeader = h('h2', { class: 'accordion-header', id: `heading-${destId}`});
          
          const accordionButton = h('button', {
              class: 'accordion-button',
              type: 'button',
              'data-bs-toggle': 'collapse',
              'data-bs-target': `#collapse-${destId}`,
              'aria-expanded': 'true',
              'aria-controls': `collapse-${destId}`,
              text: `${destination_name} 様`
          });
          accordionHeader.append(accordionButton);

          const accordionCollapse = h('div', {
              id: `collapse-${destId}`,
              class: 'accordion-collapse collapse show',
              'aria-labelledby': `heading-${destId}`,
          });

          const accordionBody = h('div', { class: 'accordion-body' });
          const container = h('div', { class: 'row' });
          
          proposal.forEach((pkg, pkgIndex) => {
              const col = h('div', { class: 'col-md-6 col-lg-4 mb-3' });
              const card = h('div', { class: 'card h-100' });
              
              let headerClass = 'card-header';
              if (pkg.note.includes('ロック中') || pkg.note.includes('維持')) {
                  headerClass += ' bg-light';
              }

              const cardHeader = h('div', { class: headerClass },
                  h('strong', { text: `箱 ${pkgIndex + 1}` }),
                  pkg.note ? h('span', { class: 'badge bg-info-subtle text-info-emphasis rounded-pill ms-2', text: pkg.note }) : '',
                  h('small', { class: 'text-muted float-end', text: `総重量: ${pkg.total_weight_kg.toFixed(2)} kg` })
              );
              const listGroup = h('ul', { class: 'list-group list-group-flush' });
              (pkg.items || []).forEach(item => {
                  const li = h('li', { class: 'list-group-item small' },
                      h('span', { class: 'd-block', text: `袋#${item.bag_id}: ${item.product_name}` })
                  );
                  listGroup.append(li);
              });
              card.append(cardHeader, listGroup);
              col.append(card);
              container.append(col);
          });
          accordionBody.append(container);
          accordionCollapse.append(accordionBody);
          accordionItem.append(accordionHeader, accordionCollapse);
          accordion.append(accordionItem);
      });

      modalBody.append(accordion);
  }

  function setupGlobalProposalModalSaveButton() {
      const applyBtn = qs('#globalProposalApplyBtn');
      if (!applyBtn) return;
      applyBtn.onclick = async (evt) => {
          const btn = evt.currentTarget;
          const modal = btn.closest('.modal');

          btn.disabled = true;
          btn.textContent = '確定処理中...';

          const res = await api(`${BASE}/packaging/apply-global-packing-proposal/`, {
              method: 'POST',
              json: {}
          });

          bootstrap.Modal.getInstance(modal)?.hide();

          if (res.ok) {
              toast(res.data?.message || '一括自動梱包を適用しました。', 'success');
              await reloadBoard();
          } else {
              toast(res.data?.error?.message || '提案の適用に失敗しました。', 'danger');
          }

          btn.disabled = false;
          btn.textContent = 'この内容で確定する';
      };
  }

  function renderBoard(state){
    const root = $root();
    root.innerHTML = '';
    renderStatusPanel(state.prepared_groups || []);
    const destinationsContainer = h('div', { id: 'destinations-container' });
    for (const d of state.destinations){
      const isCollapsed = localStorage.getItem(`dest_collapse_${d.id}`) === 'true';
      const destCard = h('div', {class: 'card mb-4', 'data-destination-id': d.id, 'data-destination-name': d.name});
      const header = h('div', {class:'card-header d-flex justify-content-between align-items-center bg-light'});
      const titleDiv = h('div', {class:'fw-bold', style: 'cursor: pointer; flex-grow: 1;'});
      const collapseIcon = h('span', {class: 'me-2', innerHTML: isCollapsed ? '▶' : '▼'});
      titleDiv.append(collapseIcon, h('span', {text: `${d.name} 様`}));
      titleDiv.onclick = () => toggleDestinationCollapse(d.id);
      const btnGroup = h('div', { class: 'd-flex align-items-center gap-2' });
      
      const btnPropose = h('button', { class: 'btn btn-sm btn-outline-success', text: '自動梱包' });
      btnPropose.onclick = () => openProposalModal(d.id, d.name);
      const btnAddBox = h('button', {class:'btn btn-sm btn-outline-primary', text:'＋ 新しい箱'});
      btnAddBox.onclick = () => createPackage(d.id);
      btnGroup.append(btnPropose, btnAddBox);
      
      header.append(titleDiv, btnGroup);
      const body = h('div', {class: isCollapsed ? 'card-body d-none' : 'card-body'});
      const wrap = h('div', {class:'d-flex flex-wrap gap-3'});
      if (d.packages.length === 0) {
        wrap.append(h('div', {class: 'text-muted p-3'}, 'この宛先の箱はまだありません。'));
      } else {
        d.packages.forEach(pkg => wrap.append(renderPackageCard(d, pkg, state)));
      }
      body.append(wrap);
      destCard.append(header, body);
      destinationsContainer.append(destCard);
    }
    root.append(destinationsContainer);
    if (!createdAutoBoxes){
      const empties = state.destinations.filter(x => (x.packages||[]).length===0).map(x=>x.id);
      if (empties.length>0){
        createdAutoBoxes = true;
        (async()=>{
          for (const did of empties){ await createPackage(did, {silent:true}); }
          await reloadBoard();
        })();
      }
    }
    populateFilters(state);
    applyFilter();
  }

  function renderPackageItem(item, destination, currentPackage) {
    const li = h('li', { class: 'dd-item d-flex justify-content-between align-items-center', 'data-product-name': item.product_name });
    const nameSpan = h('span', { text: `袋#${item.bag_id}: ${item.product_name}` });
    const controlsContainer = h('div', { class: 'd-flex align-items-center gap-1' });
    const otherPackages = destination.packages.filter(p => p.id !== currentPackage.id && p.status === 'PACKAGING');
    
    const isEditable = currentPackage.status === 'PACKAGING';
    if (isEditable) {
      if (otherPackages.length > 0) {
        const dropdownContainer = h('div', { class: 'dropdown' });
        const dropdownButton = h('button', { 
          class: 'btn btn-sm btn-outline-secondary py-0 px-1 dropdown-toggle', 
          type: 'button', 'data-bs-toggle': 'dropdown', 'aria-expanded': 'false', 
          title: '別の箱へ移動する',
          'aria-label': '別の箱へ移動する',
        });
        const dropdownMenu = h('ul', { class: 'dropdown-menu' });
        for (const targetPackage of otherPackages) {
            const itemWeight = parseFloat(item.weight_kg) || 0;
            const targetWeight = parseFloat(targetPackage.current_weight_kg) || 0;
            const maxWeight = parseFloat(targetPackage.max_weight_kg) || 25.0;
            const EPSILON = 0.001;
            const isOverweight = (targetWeight + itemWeight) > (maxWeight + EPSILON);
            
            const moveAction = h('a', { 
              class: `dropdown-item ${isOverweight ? 'disabled' : ''}`, 
              href: '#', 
              text: `箱 #${targetPackage.id} ${targetPackage.label ? `(${targetPackage.label})` : ''}`,
              title: isOverweight ? '重量オーバー' : '',
            });

            if (!isOverweight) {
              moveAction.onclick = (e) => { e.preventDefault(); movePackageItem(item.package_item_id, targetPackage.id); };
            }
            dropdownMenu.append(h('li', {}, moveAction));
        }
        dropdownContainer.append(dropdownButton, dropdownMenu);
        controlsContainer.append(dropdownContainer);
      }
      
      const unassignBtn = h('button', { 
        class: 'btn btn-sm btn-outline-danger py-0 px-1', 
        title: 'この袋を未引当に戻す', 
        innerHTML: '&times;',
      });
      unassignBtn.onclick = () => deletePackageItem(item.package_item_id);
      controlsContainer.append(unassignBtn);
    }

    li.append(nameSpan, controlsContainer);
    return li;
  }
  
  function renderPackageCard(destination, pkg, state){
    const destinationId = destination.id;
    const destinationName = destination.name;

    const isEditable = pkg.status === 'PACKAGING';
    const cardClasses = isEditable ? 'border rounded p-2' : 'border rounded p-2 bg-light';
    const card = h('div', { class: cardClasses, style:'min-width:300px; display: flex; flex-direction: column;'});

    const head = h('div', {class:'d-flex justify-content-between align-items-center mb-2'});
    const title = h('div', {class:'small fw-bold d-flex align-items-center'});
    
    const lockIcons = { 
        UNLOCKED:    '<i class="bi bi-pencil-square text-success"></i>', 
        APPEND_ONLY: '<i class="bi bi-file-earmark-plus text-warning"></i>', 
        LOCKED:      '<i class="bi bi-slash-circle text-danger"></i>' 
    };
    const lockTooltips = { UNLOCKED: '変更可', APPEND_ONLY: '追加のみ可', LOCKED: '変更不可'};
    const btnLock = h('button', { 
        class: 'btn btn-sm btn-outline-secondary py-0 px-1 me-2', 
        title: lockTooltips[pkg.lock_status],
        innerHTML: lockIcons[pkg.lock_status],
        'data-bs-toggle': 'tooltip', 
        'data-bs-placement': 'top',
    });
    
    if (!isEditable) {
        btnLock.disabled = true;
    } else {
        btnLock.onclick = () => updateLockStatus(pkg.id, pkg.lock_status);
    }
    title.append(btnLock);
    
    title.append(
      h('span', { text: `箱 #${pkg.id}` }),
      h('span', { class: 'text-muted ms-2', text: pkg.label ? `(${pkg.label})` : '' })
    );

    const controls = h('div', {class:'d-flex gap-1'});

    if (pkg.status === 'PACKAGING') {
        const btnConfirm = h('button', { class: 'btn btn-sm btn-primary py-0 px-1', title: '梱包を確定し、発送準備へ進める'});
        btnConfirm.innerHTML = '<i class="bi bi-box-arrow-up"></i> 確定';
        btnConfirm.onclick = () => updatePackageStatus(pkg.id, 'READY_TO_SHIP');
        controls.append(btnConfirm);
    } else if (pkg.status === 'READY_TO_SHIP') {
        const btnUnconfirm = h('button', { class: 'btn btn-sm btn-outline-warning py-0 px-1', title: '準備中に戻す'});
        btnUnconfirm.innerHTML = '<i class="bi bi-arrow-return-left"></i> 戻す';
        btnUnconfirm.onclick = () => updatePackageStatus(pkg.id, 'PACKAGING');
        controls.append(btnUnconfirm);
    }

    head.append(title, controls);
    const content = h('div', { style: 'flex-grow: 1;' });
    const ul = h('ul', {class:'dd-list'});
    
    (pkg.items || []).forEach(item => ul.append(renderPackageItem(item, destination, pkg)));
    
    (pkg.plans || []).forEach(plan => {
      const availableStock = state.prepared_groups.find(g => g.product_id === plan.product_id)?.qty || 0;
      
      for (let i = 0; i < plan.quantity; i++) {
        const planItem = h('li', { class: 'dd-item is-planned d-flex justify-content-between align-items-center', 'data-product-name': plan.product_name });
        planItem.append(h('span', {text: `予約: ${plan.product_name}`}));
        const btnContainer = h('div', { class: 'd-flex align-items-center gap-1' });

        if (isEditable) {
          const consumeBtn = h('button', { 
              class: `btn btn-sm ${availableStock > 0 ? 'btn-outline-success' : 'btn-secondary'} py-0 px-1`, 
              innerHTML: '📥',
              disabled: availableStock <= 0,
          });
          
          if (availableStock <= 0) {
              const wrapper = h('span', { 'data-bs-toggle': 'tooltip', 'data-bs-placement': 'top', title: '未引当の在庫がありません' });
              wrapper.append(consumeBtn);
              btnContainer.append(wrapper);
          } else {
              consumeBtn.title = 'この予約に在庫を充当する';
              consumeBtn.onclick = () => consumePlanItem(pkg.id, plan.product_id);
              btnContainer.append(consumeBtn);
          }

          const delPlanBtn = h('button', { 
            class: 'btn btn-sm btn-outline-danger py-0 px-1', 
            title: 'この予約を削除 (数量を1減らします)', 
            innerHTML: '&times;',
          });
          delPlanBtn.onclick = () => updatePlanItem(pkg.id, plan.product_id, plan.quantity - 1);
          btnContainer.append(delPlanBtn);
        }

        planItem.append(btnContainer);
        ul.append(planItem);
      }
    });

    content.append(ul);

    if (pkg.status !== 'PACKAGING') {
        let statusText = pkg.status;
        let statusClass = 'text-muted';
        if (pkg.status === 'READY_TO_SHIP') {
            statusText = '発送準備完了';
            statusClass = 'text-success fw-bold';
        } else if (pkg.status === 'LABEL_PRINTED' || pkg.status === 'SHIPPED' || pkg.status === 'DELIVERED') {
            statusText = '発送管理画面で処理中';
            statusClass = 'text-info';
        }
        const statusFooter = h('div', { class: `text-center small p-2 mt-auto ${statusClass}` }, statusText);
        content.append(statusFooter);
    }

    const footer = h('div', { class: 'text-end small text-muted mt-2' });
    const currentWeight = (pkg.current_weight_kg || 0).toFixed(2);
    const maxWeight = (pkg.max_weight_kg || 0).toFixed(2);
    footer.textContent = `重量: ${currentWeight} / ${maxWeight} kg`;
    card.append(head, content, footer);
    
    if(isEditable){
      const actionFooter = h('div', { class: 'd-flex gap-1 mt-2' });
      const btnAddBag = h('button', { class: 'btn btn-sm btn-outline-primary flex-grow-1', innerHTML: '<i class="bi bi-bag-plus"></i> 袋を追加' });
      btnAddBag.onclick = () => openAddBagModal(pkg.id, destinationId, destinationName);

      const btnAddPlan = h('button', { class: 'btn btn-sm btn-outline-info flex-grow-1', innerHTML: '<i class="bi bi-clock-history"></i> 予約を追加' });
      btnAddPlan.onclick = () => openAddPlanModal(pkg, destinationId, destinationName);

      const btnDel = h('button', { class: 'btn btn-sm btn-outline-danger', title: 'この箱を削除', innerHTML: '<i class="bi bi-trash"></i>' });
      btnDel.onclick = () => deletePackage(pkg.id);
      
      actionFooter.append(btnAddBag, btnAddPlan, btnDel);
      card.append(actionFooter);
    }

    return card;
  }
  
  async function createPackage(destinationId, {silent=false}={}){
    const res = await api(`${BASE}/packaging/packages/`, {method:'POST', json:{destination_id: destinationId}});
    if (!res.ok && !silent) { toast(res.data?.error?.message || `箱作成エラー: ${res.status}`); }
    if(!silent) { await reloadBoard(); }
  }

  async function deletePackage(packageId){
    const res = await api(`${BASE}/packaging/packages/${packageId}/`, {method:'DELETE'});
    if (!res.ok) {
        const msg = res.data?.error?.message || `箱削除エラー: ${res.status}`;
        toast(msg, 'danger');
        if (res.status === 400) { await reloadBoard(); }
    } else { await reloadBoard(); }
  }
  
  async function deletePackageItem(packageItemId) {
    const res = await api(`${BASE}/packaging/package-items/${packageItemId}/`, { method: 'DELETE' });
    if (!res.ok) { toast(res.data?.error?.message || `エラー: ${res.status}`); }
    await reloadBoard();
  }

  async function movePackageItem(packageItemId, targetPackageId) {
    const res = await api(`${BASE}/packaging/package-items/${packageItemId}/move/`, { method: 'PATCH', json: { to_package_id: targetPackageId } });
    if (!res.ok) { toast(res.data?.error?.message || `移動エラー: ${res.status}`); }
    await reloadBoard();
  }
  
  async function updatePlanItem(packageId, productId, newQuantity) {
    const res = await api(`${BASE}/packaging/plan-items/`, { method: 'POST', json: { package_id: packageId, product_id: productId, quantity: newQuantity } });
    if (!res.ok) { toast(res.data?.error?.message || `予約更新エラー: ${res.status}`); }
    await reloadBoard();
  }

  async function consumePlanItem(packageId, productId) {
    const res = await api(`${BASE}/packaging/plan-items/consume/`, {
        method: 'POST',
        json: { package_id: packageId, product_id: productId, count: 1 }
    });
    if (!res.ok) {
        toast(res.data?.error?.message || `予約充当エラー: ${res.status}`);
    }
    await reloadBoard();
  }

  function toggleDestinationCollapse(destinationId) {
    const destCard = qs(`.card[data-destination-id='${destinationId}']`);
    if (!destCard) return;
    const body = qs('.card-body', destCard);
    const icon = qs('.card-header span', destCard);
    const isCollapsing = !body.classList.contains('d-none');
    if (isCollapsing) {
      body.classList.add('d-none');
      icon.innerHTML = '▶';
      localStorage.setItem(`dest_collapse_${destinationId}`, 'true');
    } else {
      body.classList.remove('d-none');
      icon.innerHTML = '▼';
      localStorage.setItem(`dest_collapse_${destinationId}`, 'false');
    }
  }

  function parseProductName(name) {
    const parts = (name || '').split(' ');
    if (parts.length < 2) return { variety: name, milling: '', weight: '' };
    const weightPart = parts.find(p => p.endsWith('kg')) || '';
    const millingPart = parts.find(p => p === '玄米' || p === '精米') || '';
    const varietyPart = parts.filter(p => p !== weightPart && p !== millingPart).join(' ');
    return { variety: varietyPart, milling: millingPart, weight: weightPart };
  }

  function populateFilters(state) {
    const varietySelect = qs('#filter-variety');
    const millingSelect = qs('#filter-milling');
    const weightSelect = qs('#filter-weight');
    const current = { variety: varietySelect.value, milling: millingSelect.value, weight: weightSelect.value };
    varietySelect.length = 1; millingSelect.length = 1; weightSelect.length = 1;
    const allProdNames = new Set();
    (state.destinations || []).forEach(d => {
      (d.packages || []).forEach(p => {
        (p.items || []).forEach(i => allProdNames.add(i.product_name));
        (p.plans || []).forEach(pl => allProdNames.add(pl.product_name));
      });
    });
    const options = { varieties: new Set(), millings: new Set(), weights: new Set() };
    allProdNames.forEach(name => {
      const parsed = parseProductName(name);
      if (parsed.variety) options.varieties.add(parsed.variety);
      if (parsed.milling) options.millings.add(parsed.milling);
      if (parsed.weight) options.weights.add(parsed.weight);
    });
    Array.from(options.varieties).sort().forEach(v => varietySelect.append(h('option', {value: v, text: v})));
    Array.from(options.millings).sort().forEach(m => millingSelect.append(h('option', {value: m, text: m})));
    Array.from(options.weights).sort((a,b) => parseFloat(a) - parseFloat(b)).forEach(w => weightSelect.append(h('option', {value: w, text: w})));
    varietySelect.value = current.variety; millingSelect.value = current.milling; weightSelect.value = current.weight;
  }

  function applyFilter() {
    const destKeyword = qs('#filter-destination').value.toLowerCase().trim();
    const varietyFilter = qs('#filter-variety').value;
    const millingFilter = qs('#filter-milling').value;
    const weightFilter = qs('#filter-weight').value;
    const destCards = qsa('#destinations-container .card');
    for (const card of destCards) {
      const destName = (card.dataset.destinationName || '').toLowerCase();
      const destMatch = !destKeyword || destName.includes(destKeyword);
      if (!destMatch) { card.style.display = 'none'; continue; }
      const items = qsa('.dd-item', card);
      const hasProductFilter = varietyFilter || millingFilter || weightFilter;
      const productMatch = !hasProductFilter || items.some(item => {
        const name = item.dataset.productName || '';
        if (!name) return false;
        const parsed = parseProductName(name);
        const varietyMatch = !varietyFilter || parsed.variety === varietyFilter;
        const millingMatch = !millingFilter || parsed.milling === millingFilter;
        const weightMatch = !weightFilter || parsed.weight === weightFilter;
        return varietyMatch && millingMatch && weightMatch;
      });
      card.style.display = (destMatch && productMatch) ? '' : 'none';
    }
  }

  function setupFilter() {
    qs('#filter-destination')?.addEventListener('input', applyFilter);
    qs('#filter-variety')?.addEventListener('change', applyFilter);
    qs('#filter-milling')?.addEventListener('change', applyFilter);
    qs('#filter-weight')?.addEventListener('change', applyFilter);
  }

  async function reloadBoard(){
    const root = $root(); 
    root.innerHTML = '<div class="alert alert-secondary">読込中...</div>';
    const res = await api(`${BASE}/packaging/board-state/`);
    if (!res.ok){
      root.innerHTML = `<div class="alert alert-danger">読み込み失敗: ${res.status}</div>`;
      return;
    }
    renderBoard(res.data);
    await updateSidebarSummary();
    initializeTooltips();
  }
  
  ready(async () => {
    initializeToast();
    setupModalSaveButton();
    setupPlanModalSaveButton();
    setupProposalModalSaveButton();
    setupGlobalProposalModalSaveButton();
    qs('#global-proposal-btn')?.addEventListener('click', openGlobalProposalModal);
    setupFilter();
    await reloadBoard();
  });
})();
```

##### **ファイル:** `mg_workflow/static/mg_workflow/js/shipping_list.js` **(新規作成)**

* `static` ディレクトリの下に `mg_workflow/js` というディレクトリを作成し、そこに保存してください。

```javascript
// mg_workflow/static/mg_workflow/js/shipping_list.js
(() => {
  const BASE_API_URL = "/management/workflow/api/shipping";
  let appToastInstance = null;
  let allPackages = [];

  function h(tag, props = {}, ...children) {
    const el = document.createElement(tag);
    Object.entries(props || {}).forEach(([key, value]) => {
      if (key === 'class') el.className = value;
      else if (key.startsWith('data-')) el.setAttribute(key, value);
      else if (key.startsWith('on') && typeof value === 'function') {
        el.addEventListener(key.substring(2).toLowerCase(), value);
      }
      else if (key === 'html') el.innerHTML = value;
      else if (key === 'text') el.textContent = value;
      else el[key] = value;
    });
    children.forEach(child => el.append(child));
    return el;
  }
  
  function showToast(message, type = 'success') {
      if (!appToastInstance) { alert(message); return; }
      const toastEl = appToastInstance._element;
      const toastHeader = toastEl.querySelector('.toast-header');
      const toastTitle = toastEl.querySelector('#appToastTitle');
      const toastBody = toastEl.querySelector('#appToastBody');
      toastBody.textContent = message;
      toastHeader.classList.remove('bg-success', 'bg-danger', 'text-white');
      if (type === 'success') {
          toastTitle.textContent = '成功';
          toastHeader.classList.add('bg-success', 'text-white');
      } else {
          toastTitle.textContent = 'エラー';
          toastHeader.classList.add('bg-danger', 'text-white');
      }
      appToastInstance.show();
  }

  function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
  }

  async function api(path, { method = 'GET', json, body, headers, expect = 'json' } = {}) {
    const hds = { 'X-CSRFToken': getCookie('csrftoken'), ...headers };
    let reqBody = body;
    if (json !== undefined) {
      hds['Content-Type'] = 'application/json';
      reqBody = JSON.stringify(json);
    }
    const res = await fetch(path, { method, headers: hds, body: reqBody });
    
    if (expect === 'json') {
      const data = await res.json().catch(() => null);
      return { ok: res.ok, status: res.status, data };
    }
    if (expect === 'blob') {
      const blob = await res.blob();
      return { ok: res.ok, status: res.status, blob, headers: res.headers };
    }
    return { ok: res.ok, status: res.status };
  }

  async function fetchShippingData() {
    const res = await api(`${BASE_API_URL}/data/`);
    if (res.ok) {
      allPackages = res.data.shipping_packages || [];
      render(allPackages);
    } else {
      showToast('データの読み込みに失敗しました。', 'danger');
    }
  }

  async function handleStatusUpdate(packageIds, newStatus) {
      if(packageIds.length === 0) { showToast('対象の荷物が選択されていません。', 'danger'); return; }
      const res = await api(`${BASE_API_URL}/packages/status/`, { method: 'POST', json: { package_ids: packageIds, status: newStatus } });
      if (res.ok) { showToast(res.data.message, 'success'); fetchShippingData(); } 
      else { showToast(`エラー: ${res.data?.error?.message || '更新に失敗しました。'}`, 'danger'); }
  }

  async function handleCsvExport(packageIds) {
      if (packageIds.length === 0) { showToast('CSVを出力する荷物を選択してください。', 'danger'); return; }
      const res = await api(`${BASE_API_URL}/download-b2-csv/`, { method: 'POST', json: { package_ids: packageIds }, expect: 'blob' });
      if (res.ok) {
          const header = res.headers.get('content-disposition');
          const filename = header ? header.split('filename=')[1].replace(/"/g, '') : 'b2_export.csv';
          const a = document.createElement('a');
          a.href = URL.createObjectURL(res.blob);
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          showToast(`${packageIds.length}件のCSVファイルを出力しました。`, 'success');
          fetchShippingData();
      } else { showToast('CSVの出力に失敗しました。', 'danger'); }
  }

  async function handleResetCsvStatus(packageIds) {
      if (packageIds.length === 0) { showToast('「CSV出力前」に戻す荷物を選択してください。', 'danger'); return; }
      const res = await api(`${BASE_API_URL}/packages/reset-csv-status/`, { method: 'POST', json: { package_ids: packageIds } });
      if (res.ok) { showToast(res.data.message, 'success'); fetchShippingData(); } 
      else { showToast(`エラー: ${res.data?.error?.message || '更新に失敗しました。'}`, 'danger'); }
  }

  function getActiveTabContext() {
    const activeTab = document.querySelector('#shippingTab .nav-link.active');
    return activeTab ? activeTab.id.split('-')[0] : null;
  }

  function getSelectedPackageIds() {
    const context = getActiveTabContext();
    if (!context) return [];
    const panelId = `#${context}-panel`;
    return Array.from(document.querySelectorAll(`${panelId} .package-checkbox:checked`)).map(cb => parseInt(cb.dataset.packageId, 10));
  }
  
  function updateBulkActionPanel() {
      const context = getActiveTabContext();
      if (!context) return;
      const panel = document.getElementById(`bulk-actions-${context}`);
      if (!panel) return;
      const executionControls = panel.querySelector(`#bulk-execution-controls-${context}`);
      if (!executionControls) return;
      const countSpan = executionControls.querySelector('.selected-count');
      const executionButtons = executionControls.querySelectorAll('button');
      const selectedIds = getSelectedPackageIds();
      const hasSelection = selectedIds.length > 0;
      countSpan.parentElement.classList.toggle('text-muted', !hasSelection);
      countSpan.textContent = selectedIds.length;
      executionButtons.forEach(btn => { btn.disabled = !hasSelection; });
  }

  function setupBulkActionListeners() {
      const addListener = (id, event, handler) => {
          const el = document.getElementById(id);
          if (el) { el.addEventListener(event, handler); } 
          else { console.warn(`Element with ID "${id}" not found.`); }
      };
      addListener('filter-select-unexported', 'click', () => { document.querySelectorAll('#ready-panel .package-checkbox').forEach(cb => { const row = cb.closest('.package-row'); cb.checked = row ? !row.classList.contains('is-exported') : false; }); updateBulkActionPanel(); });
      addListener('filter-select-exported', 'click', () => { document.querySelectorAll('#ready-panel .package-checkbox').forEach(cb => { const row = cb.closest('.package-row'); cb.checked = row ? row.classList.contains('is-exported') : false; }); updateBulkActionPanel(); });
      addListener('filter-select-all', 'click', () => { document.querySelectorAll('#ready-panel .package-checkbox').forEach(cb => cb.checked = true); updateBulkActionPanel(); });
      addListener('filter-select-none', 'click', () => { document.querySelectorAll('#ready-panel .package-checkbox').forEach(cb => cb.checked = false); updateBulkActionPanel(); });
      addListener('bulk-csv-export-btn', 'click', () => handleCsvExport(getSelectedPackageIds()));
      addListener('bulk-mark-as-printed-btn', 'click', () => handleStatusUpdate(getSelectedPackageIds(), 'LABEL_PRINTED'));
      addListener('bulk-reset-csv-status-btn', 'click', () => handleResetCsvStatus(getSelectedPackageIds()));
      addListener('bulk-revert-to-packaging-btn', 'click', () => handleStatusUpdate(getSelectedPackageIds(), 'PACKAGING'));
      addListener('printed-select-all', 'click', () => { document.querySelectorAll('#printed-panel .package-checkbox').forEach(cb => cb.checked = true); updateBulkActionPanel(); });
      addListener('printed-select-none', 'click', () => { document.querySelectorAll('#printed-panel .package-checkbox').forEach(cb => cb.checked = false); updateBulkActionPanel(); });
      addListener('bulk-mark-as-shipped-btn', 'click', () => handleStatusUpdate(getSelectedPackageIds(), 'SHIPPED'));
      addListener('bulk-revert-to-ready-btn', 'click', () => handleStatusUpdate(getSelectedPackageIds(), 'READY_TO_SHIP'));
      addListener('done-select-all', 'click', () => { document.querySelectorAll('#done-panel .package-checkbox').forEach(cb => cb.checked = true); updateBulkActionPanel(); });
      addListener('done-select-none', 'click', () => { document.querySelectorAll('#done-panel .package-checkbox').forEach(cb => cb.checked = false); updateBulkActionPanel(); });
      addListener('bulk-revert-to-printed-btn', 'click', () => { const targetIds = allPackages.filter(p => getSelectedPackageIds().includes(p.id) && p.status === 'SHIPPED').map(p => p.id); handleStatusUpdate(targetIds, 'LABEL_PRINTED'); });
      addListener('bulk-revert-to-ready-from-done-btn', 'click', () => { const targetIds = allPackages.filter(p => getSelectedPackageIds().includes(p.id) && p.status === 'DELIVERED').map(p => p.id); handleStatusUpdate(targetIds, 'READY_TO_SHIP'); });
  }

  function setupTabListeners() {
    document.querySelectorAll('#shippingTab button[data-bs-toggle="tab"]').forEach(tabEl => {
      tabEl.addEventListener('shown.bs.tab', event => {
        const context = event.target.id.split('-')[0];
        document.querySelectorAll('.bulk-actions-panel').forEach(p => p.classList.add('d-none'));
        const activePanel = document.getElementById(`bulk-actions-${context}`);
        if(activePanel) activePanel.classList.remove('d-none');
        updateBulkActionPanel();
      });
    });
  }

  function setupCsvImportListener() {
    const importBtn = document.getElementById('import-csv-btn');
    const fileInput = document.getElementById('csv-file-input');
    if (!importBtn || !fileInput) return;
    
    importBtn.addEventListener('click', () => fileInput.click());
    
    fileInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const formData = new FormData();
        formData.append('csv_file', file);
        
        importBtn.disabled = true;
        importBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> 取込中...';

        const res = await api(`${BASE_API_URL}/import-tracking-numbers/`, {
            method: 'POST',
            body: formData,
            expect: 'json',
        });
        
        if (res.ok) {
            showToast(res.data.message, 'success');
            fetchShippingData();
        } else {
            showToast(`エラー: ${res.data?.error?.message || '取込に失敗しました。'}`, 'danger');
        }
        
        importBtn.disabled = false;
        importBtn.innerHTML = '<i class="bi bi-file-earmark-arrow-up"></i> 伝票番号CSV取込';
        event.target.value = '';
    });
  }

  function render(packages) {
    const tbodies = { ready: document.querySelector('[data-tbody-ready]'), printed: document.querySelector('[data-tbody-printed]'), done: document.querySelector('[data-tbody-done]') };
    Object.values(tbodies).forEach(tbody => { if(tbody) tbody.innerHTML = ''; });
    const destPackageMap = packages.reduce((acc, pkg) => {
        const destId = pkg.destination.id;
        if (!acc[destId]) acc[destId] = { destination: pkg.destination, packages: [] };
        acc[destId].packages.push(pkg);
        return acc;
    }, {});
    const counts = { ready: 0, printed: 0, done: 0 };
    const sortedDests = Object.values(destPackageMap).sort((a,b) => a.destination.name.localeCompare(b.destination.name));
    sortedDests.forEach(destGroup => {
        const pkgsByStatus = {
            ready: destGroup.packages.filter(p => p.status === 'READY_TO_SHIP'),
            printed: destGroup.packages.filter(p => p.status === 'LABEL_PRINTED'),
            done: destGroup.packages.filter(p => ['SHIPPED', 'DELIVERED'].includes(p.status))
        };
        if (pkgsByStatus.ready.length > 0) { counts.ready += pkgsByStatus.ready.length; tbodies.ready.append(renderDestinationRow(destGroup.destination, pkgsByStatus.ready, 'ready')); pkgsByStatus.ready.forEach(pkg => tbodies.ready.append(renderPackageRow(pkg, 'ready'))); }
        if (pkgsByStatus.printed.length > 0) { counts.printed += pkgsByStatus.printed.length; tbodies.printed.append(renderDestinationRow(destGroup.destination, pkgsByStatus.printed, 'printed')); pkgsByStatus.printed.forEach(pkg => tbodies.printed.append(renderPackageRow(pkg, 'printed'))); }
        if (pkgsByStatus.done.length > 0) { counts.done += pkgsByStatus.done.length; tbodies.done.append(renderDestinationRow(destGroup.destination, pkgsByStatus.done, 'done')); pkgsByStatus.done.forEach(pkg => tbodies.done.append(renderPackageRow(pkg, 'done'))); }
    });
    document.querySelector('[data-count-ready]').textContent = counts.ready;
    document.querySelector('[data-count-printed]').textContent = counts.printed;
    document.querySelector('[data-count-done]').textContent = counts.done;
    Object.entries(counts).forEach(([key, count]) => {
        const table = tbodies[key].parentElement;
        const emptyMsg = document.querySelector(`[data-empty-${key}]`);
        table.classList.toggle('d-none', count === 0);
        emptyMsg.classList.toggle('d-none', count > 0);
    });
    updateBulkActionPanel();
  }

  function renderDestinationRow(destination, packages, context) {
      const row = h('tr', { class: 'destination-group-row' });
      const checkboxCell = h('td');
      if (['ready', 'printed', 'done'].includes(context)) {
          const cb = h('input', { type: 'checkbox', class: 'form-check-input dest-checkbox', 'data-dest-id': destination.id });
          cb.addEventListener('change', (e) => {
              document.querySelectorAll(`#${context}-panel .package-checkbox[data-dest-id='${destination.id}']`).forEach(pkg_cb => { pkg_cb.checked = e.target.checked; });
              updateBulkActionPanel();
          });
          checkboxCell.append(cb);
      }
      row.append(checkboxCell, h('td', { colspan: 2 }, `${destination.name} 様 (${packages.length}箱)`), h('td', { colspan: 3, class: 'small' }, destination.delivery_method === 'YAMATO' ? 'ヤマト配送' : '直接手渡し'));
      return row;
  }

  function renderPackageRow(pkg, context) {
    const rowClasses = `package-row ${pkg.csv_exported_at ? 'is-exported' : ''}`;
    const row = h('tr', { class: rowClasses, 'data-package-id': pkg.id });
    const checkboxCell = h('td');
     if (['ready', 'printed', 'done'].includes(context)) {
        const cb = h('input', { type: 'checkbox', class: 'form-check-input package-checkbox', 'data-package-id': pkg.id, 'data-dest-id': pkg.destination.id });
        cb.addEventListener('change', updateBulkActionPanel);
        checkboxCell.append(cb);
    }
    row.append(
      checkboxCell,
      h('td', { class: 'package-row-item' }, `└ 箱 #${pkg.id}`),
      h('td', { class: 'small text-muted' }, pkg.items_summary),
      h('td', { class: 'small' }, pkg.tracking_number || 'ー'),
      h('td', {}, h('span', { class: `badge bg-${getStatusColor(pkg)}`, text: pkg.status_display })),
      h('td', { class: 'd-flex flex-wrap gap-1' }, ...renderActionButtonsForPackage(pkg))
    );
    return row;
  }
  
  function renderActionButtonsForPackage(pkg) {
    const buttons = []; const status = pkg.status;
    if (status === 'READY_TO_SHIP') {
      if (pkg.destination.delivery_method === 'YAMATO') {
          if (pkg.csv_exported_at) { buttons.push(h('button', {class: 'btn btn-sm btn-warning', text: 'CSV再出力', onclick: () => handleCsvExport([pkg.id]) }), h('button', {class: 'btn btn-sm btn-outline-secondary', text: '出力前に戻す', onclick: () => handleResetCsvStatus([pkg.id]) })); } 
          else { buttons.push(h('button', {class: 'btn btn-sm btn-primary', text: 'CSV出力', onclick: () => handleCsvExport([pkg.id]) })); }
      } else { buttons.push(h('button', {class: 'btn btn-sm btn-success', html: '<i class="bi bi-person-check"></i> 手渡し完了', onclick: () => handleStatusUpdate([pkg.id], 'DELIVERED')})); }
      buttons.push(h('button', {class: 'btn btn-sm btn-outline-secondary', html: '<i class="bi bi-arrow-return-left"></i> 梱包へ戻す', onclick: () => handleStatusUpdate([pkg.id], 'PACKAGING')}));
    } else if (status === 'LABEL_PRINTED') { buttons.push(h('button', {class: 'btn btn-sm btn-success', html: '<i class="bi bi-truck"></i> 発送完了にする', onclick: () => handleStatusUpdate([pkg.id], 'SHIPPED')}), h('button', {class: 'btn btn-sm btn-outline-secondary', html: '<i class="bi bi-arrow-return-left"></i> 発送準備完了に戻す', onclick: () => handleStatusUpdate([pkg.id], 'READY_TO_SHIP')}));
    } else if (status === 'SHIPPED') { buttons.push(h('button', {class: 'btn btn-sm btn-outline-danger', html: '<i class="bi bi-arrow-return-left"></i> 伝票印刷済みに戻す', onclick: () => handleStatusUpdate([pkg.id], 'LABEL_PRINTED')}));
    } else if (status === 'DELIVERED') { buttons.push(h('button', {class: 'btn btn-sm btn-outline-danger', html: '<i class="bi bi-arrow-return-left"></i> 発送準備完了に戻す', onclick: () => handleStatusUpdate([pkg.id], 'READY_TO_SHIP')})); }
    return buttons;
  }

  function getStatusColor(pkg) {
    if (pkg.status === 'READY_TO_SHIP') { return pkg.csv_exported_at ? 'warning' : 'primary'; }
    switch (pkg.status) { case 'LABEL_PRINTED': return 'info'; case 'SHIPPED': return 'success'; case 'DELIVERED': return 'success'; default: return 'secondary'; }
  }

  document.addEventListener('DOMContentLoaded', () => {
      const toastEl = document.getElementById('appToast');
      if (toastEl) { appToastInstance = new bootstrap.Toast(toastEl, { delay: 4000 }); }
      fetchShippingData();
      setupBulkActionListeners();
      setupTabListeners();
      setupCsvImportListener();
      const initialContext = getActiveTabContext();
      document.querySelectorAll('.bulk-actions-panel').forEach(p => p.classList.add('d-none'));
      const initialActivePanel = document.getElementById(`bulk-actions-${initialContext}`);
      if(initialActivePanel) initialActivePanel.classList.remove('d-none');
      updateBulkActionPanel();
  });
})();
```

#### 6. 手順5：データベースへの反映と動作確認

1. **データベースマイグレーションの実行:**
    この手順書ではモデル構造に変更がないため、マイグレーションコマンドの実行は不要です。

2. **動作確認:**
    * 管理者としてログインし、サイドバーの「出荷ワークフロー」から各画面にアクセスできることを確認します。
    * **袋詰管理画面:**
        * URLが`/management/workflow/bagging/`となっていることを確認します。
        * 「要袋詰リスト」が表示され、数量を入力して袋詰完了を登録できることを確認します。
    * **自動引当ボード:**
        * URLが`/management/workflow/packaging/`となっていることを確認します。
        * 袋詰した在庫が表示され、宛先ごとの箱にドラッグ＆ドロップ（またはボタン操作）で梱包できることを確認します。
        * 「自動梱包」「一括自動梱包」機能が正しく動作し、提案モーダルが表示され、適用できることを確認します。
    * **発送管理画面:**
        * URLが`/management/workflow/shipping/`となっていることを確認します。
        * 梱包が確定した箱が「発送準備完了」タブに表示されることを確認します。
        * CSV出力、伝票番号のインポート、ステータスの更新など、すべての機能が一括・個別で正しく動作することを確認します。
    * **サイドバー:**
        * 「袋在庫サマリー」が正しく表示され、袋詰や梱包の操作を行うと数値がリアルタイム（ページリロード後）に更新されることを確認します。

---
