
### **【機能単位】管理者向け出荷ワークフロー機能 実装手順書 (Ver. 3.1) の更新**

##### **ファイル:** `35_管理者向け出荷ワークフロー機能 実装手順書.md` **(全面的に上書き)**

```markdown
### **【機能単位】管理者向け出荷ワークフロー機能 実装手順書 (Ver. 3.1)**

#### 1. 目的

この手順書は、`【機能単位】管理者向け顧客管理機能 実装手順書 (Ver. 3.0)`までが完了した状態から、管理者が注文受付後に行う一連の出荷作業（袋詰 → 梱包 → 発送）を、新設された`mg_workflow`アプリケーションとして実装するための公式ドキュメントです。

#### 2. 手順1：システム設定と共通表示の拡張

##### **ファイル:** `config/settings.py` **(全面的に上書き)**

* パッケージングの重量計算に使用する定数を追加します。

```python
# config/settings.py
import os
from pathlib import Path
from dotenv import load_dotenv
import socket

BASE_DIR = Path(__file__).resolve().parent.parent

load_dotenv()

SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')
DEBUG = os.getenv('DJANGO_DEBUG', 'False') == 'True'

# .envファイルから読み込んだホスト名をリスト化
ALLOWED_HOSTS = os.getenv('DJANGO_ALLOWED_HOSTS', '').split(',')

if DEBUG:
    # 開発時はlocalhostを追加
    ALLOWED_HOSTS.extend(['localhost', '127.0.0.1'])
else:
    # 本番時はTraefikからの内部アクセス用にlocalhostを追加
    ALLOWED_HOSTS.append('localhost')

CSRF_TRUSTED_ORIGINS = os.getenv('DJANGO_CSRF_TRUSTED_ORIGINS', '').split(',')

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'whitenoise.runserver_nostatic',
    'django.contrib.staticfiles',
    'django.contrib.humanize',
    'bootstrap5',
    'django_extensions',
    'accounts.apps.AccountsConfig',
    'products.apps.ProductsConfig',
    'orders.apps.OrdersConfig',
    'cart.apps.CartConfig',
    'system_settings.apps.SystemSettingsConfig',
    'dashboard.apps.DashboardConfig',
    'mg_orders.apps.MgOrdersConfig',
    'mg_customers.apps.MgCustomersConfig',
    'mg_masters.apps.MgMastersConfig',
    'mg_workflow.apps.MgWorkflowConfig',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

if DEBUG:
    INSTALLED_APPS.append('debug_toolbar')
    MIDDLEWARE.append('debug_toolbar.middleware.DebugToolbarMiddleware')

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'cart.context_processors.cart_context',
                'dashboard.context_processors.bag_stock_summary',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': os.getenv('MYSQL_DATABASE'),
        'USER': os.getenv('MYSQL_USER'),
        'PASSWORD': os.getenv('MYSQL_PASSWORD'),
        'HOST': os.getenv('MYSQL_HOST', 'db'),
        'PORT': '3306',
        'OPTIONS': {'charset': 'utf8mb4'},
    }
}

AUTH_PASSWORD_VALIDATORS = []

LANGUAGE_CODE = 'ja'
TIME_ZONE = 'Asia/Tokyo'
USE_I18N = True
USE_L10N = True
USE_THOUSAND_SEPARATOR = True
NUMBER_GROUPING = 3
USE_TZ = True

STATIC_URL = 'static/'
STATICFILES_DIRS = [BASE_DIR / "static"]
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

INTERNAL_IPS = [ "127.0.0.1", ]
if DEBUG:
    try:
        hostname, _, ips = socket.gethostbyname_ex(socket.gethostname())
        INTERNAL_IPS.extend([ip[: ip.rfind(".")] + ".1" for ip in ips])
    except socket.gaierror:
        pass

# --- My Settings ---
AUTH_USER_MODEL = 'accounts.User'
LOGIN_URL = 'accounts:login'
LOGIN_REDIRECT_URL = 'products:product_list'
LOGOUT_REDIRECT_URL = 'accounts:login'
CART_SESSION_ID = 'cart'
CART_HYBRID_THRESHOLD = 3
NORMAL_SHIPPING_FEE = 1200
REMOTE_SHIPPING_FEE = 1800
SEIMAI_WEIGHT_COEFFICIENT = 1.1
PACKAGE_MAX_WEIGHT_KG = 25.0
DEFAULT_BOX_WEIGHT_KG = 0.5

if not DEBUG:
    SECURE_SSL_REDIRECT = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
```

##### **ファイル:** `dashboard/context_processors.py` **(全面的に上書き)**

* サイドバーの「袋在庫サマリー」に「出荷済」の袋数を計算するロジックを追加します。

```python
# dashboard/context_processors.py

# ▼▼▼ 変更点: Packageモデルをインポートリストに追加 ▼▼▼
from django.db.models import Sum, Count, Q
from orders.models import Order, OrderItem, Bag, PackageItem, Package
# ▲▲▲ 変更点ここまで ▲▲▲
from products.models import Stock, Product
from cart.cart import Cart
from decimal import Decimal
from django.conf import settings

def stock_summary(request):
    """
    サイドバーにお客様向けの在庫状況を表示するためのコンテキストプロセッサ。
    """
    if not request.user.is_authenticated or request.user.is_staff:
        return {}

    cart = Cart(request)
    cart_consumption_by_variety = {}
    seimai_coeff = Decimal(str(settings.SEIMAI_WEIGHT_COEFFICIENT))

    all_product_ids_in_cart = [pid for d in cart.cart.values() for pid in d.get('items', {}).keys()]
    all_products_map = {p.id: p for p in Product.objects.filter(id__in=all_product_ids_in_cart).select_related('variety')}

    for dest_data in cart.cart.values():
        for prod_id_str, item_data in dest_data.get('items', {}).items():
            product = all_products_map.get(int(prod_id_str))
            if product:
                quantity = item_data.get('quantity', 0)
                variety_id = product.variety.id
                
                weight_in_cart = product.weight_kg * quantity
                if product.type == Product.ProductType.SEIMAI:
                    weight_in_cart *= seimai_coeff
                
                cart_consumption_by_variety.setdefault(variety_id, Decimal('0'))
                cart_consumption_by_variety[variety_id] += weight_in_cart

    stocks = Stock.objects.select_related('variety').order_by('variety__name')
    summary = []
    for stock in stocks:
        summary.append({
            'name': stock.variety.name,
            'available_kg': stock.available_kg,
            'cart_consumption_kg': cart_consumption_by_variety.get(stock.variety.id, Decimal('0'))
        })
        
    return {'stock_summary': summary}

def bag_stock_summary(request):
    """
    サイドバーの在庫サマリー（物理ベース）
    """
    if not request.user.is_authenticated or not request.user.is_staff:
        return {}

    required_qs = (
        OrderItem.objects
        .filter(order__status=Order.OrderStatus.ACCEPTED)
        .values('product_id', 'product__name')
        .annotate(q=Sum('quantity'))
    )
    by_prod = {}
    for r in required_qs:
        pid = r['product_id']
        by_prod[pid] = {
            'name': r['product__name'],
            'total_ordered': int(r['q'] or 0),
            'prepared_total': 0,
            'packed_total': 0,
            # ▼▼▼ 変更点: shipped_totalの初期値を追加 ▼▼▼
            'shipped_total': 0,
            # ▲▲▲ 変更点ここまで ▲▲▲
        }

    # ▼▼▼ 変更点: 出荷済みの袋数を集計するアノテーションを追加 ▼▼▼
    prepared_bags_qs = (
        Bag.objects
        .filter(prepared=True)
        .values('product_id')
        .annotate(
            total_prepared_count=Count('id'),
            total_packed_count=Count('packageitem', filter=Q(packageitem__isnull=False)),
            total_shipped_count=Count(
                'packageitem', 
                filter=Q(packageitem__package__status__in=[
                    Package.PackageStatus.SHIPPED,
                    Package.PackageStatus.DELIVERED,
                ])
            )
        )
    )
    # ▲▲▲ 変更点ここまで ▲▲▲

    for row in prepared_bags_qs:
        pid = row['product_id']
        if pid in by_prod:
            by_prod[pid]['prepared_total'] = int(row['total_prepared_count'] or 0)
            by_prod[pid]['packed_total'] = int(row['total_packed_count'] or 0)
            # ▼▼▼ 変更点: shipped_totalの値を取得 ▼▼▼
            by_prod[pid]['shipped_total'] = int(row['total_shipped_count'] or 0)
            # ▲▲▲ 変更点ここまで ▲▲▲

    rows = []
    for pid, data in by_prod.items():
        total_ordered = data['total_ordered']
        prepared_total = data['prepared_total']
        packed_total = data['packed_total']
        # ▼▼▼ 変更点: shipped_totalを取得 ▼▼▼
        shipped_total = data['shipped_total']
        # ▲▲▲ 変更点ここまで ▲▲▲

        unbagged_count = max(0, total_ordered - prepared_total)
        
        unpacked_count = max(0, prepared_total - packed_total)

        # ▼▼▼ 変更点: 「箱入」の数を「梱包済みだが未出荷」の数に変更 ▼▼▼
        boxed_but_not_shipped_count = max(0, packed_total - shipped_total)
        # ▲▲▲ 変更点ここまで ▲▲▲

        rows.append({
            'name': data['name'],
            'total': total_ordered,
            'unbagged': unbagged_count,
            'bag_rice': unpacked_count,
            # ▼▼▼ 変更点: 'boxed'の値を差し替え、'shipped'を追加 ▼▼▼
            'boxed': boxed_but_not_shipped_count,
            'shipped': shipped_total,
            # ▲▲▲ 変更点ここまで ▲▲▲
        })

    rows.sort(key=lambda x: x['name'])
    return {'bag_stock_summary': rows}
```

##### **ファイル:** `templates/base_management.html` **(全面的に上書き)**

* サイドバーの在庫サマリーテーブルに「出荷済」列を追加し、説明文を更新します。

```html
{% extends "base.html" %}
{% block sidebar_content %}
    <h3>メニュー</h3>
    <hr>
    <p>こんにちは、{{ user.username }} さん</p>
    <ul class="nav flex-column mb-3">
        <li class="nav-item">
            <a class="nav-link" href="{% url 'dashboard:dashboard_top' %}"><i class="bi bi-speedometer2 me-2"></i>ダッシュボード</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="{% url 'dashboard:mg_orders:order_list' %}"><i class="bi bi-card-list me-2"></i>注文管理</a>
        </li>
        <li class="nav-item">
            <a class="nav-link"
               href="{% url 'dashboard:mg_customers:customer_list' %}"><i class="bi bi-people me-2"></i>顧客管理</a>
        </li>
        <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle"
               href="#"
               role="button"
               data-bs-toggle="dropdown"
               aria-expanded="false">
                <i class="bi bi-box-seam me-2"></i>出荷ワークフロー
            </a>
            <ul class="dropdown-menu">
                <li>
                    <a class="dropdown-item"
                       href="{% url 'dashboard:mg_workflow:bagging_list' %}">袋詰管理</a>
                </li>
                <li>
                    <a class="dropdown-item"
                       href="{% url 'dashboard:mg_workflow:packaging_board' %}">自動引当ボード</a>
                </li>
                <li>
                    <a class="dropdown-item"
                       href="{% url 'dashboard:mg_workflow:shipping_list' %}">発送管理</a>
                </li>
            </ul>
        </li>
        <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle"
               href="#"
               role="button"
               data-bs-toggle="dropdown"
               aria-expanded="false">
                <i class="bi bi-database me-2"></i>マスタ管理
            </a>
            <ul class="dropdown-menu">
                <li>
                    <a class="dropdown-item"
                       href="{% url 'dashboard:mg_masters:variety_list' %}">品種マスタ</a>
                </li>
                <li>
                    <a class="dropdown-item"
                       href="{% url 'dashboard:mg_masters:product_list' %}">商品マスタ</a>
                </li>
                <li>
                    <a class="dropdown-item"
                       href="{% url 'dashboard:mg_masters:stock_list' %}">在庫マスタ</a>
                </li>
                <li>
                    <hr class="dropdown-divider">
                </li>
                <li>
                    <a class="dropdown-item" href="{% url 'dashboard:manuals' %}">マニュアル管理</a>
                </li>
            </ul>
        </li>
        <li class="nav-item dropdown mt-2 border-top pt-2">
            <a class="nav-link dropdown-toggle"
               href="#"
               role="button"
               data-bs-toggle="dropdown"
               aria-expanded="false">
                <i class="bi bi-gear me-2"></i>システム設定
            </a>
            <ul class="dropdown-menu">
                <li>
                    <a class="dropdown-item" href="{% url 'admin:index' %}" target="_blank">Django管理サイト</a>
                </li>
                <li>
                    <a class="dropdown-item" href="{% url 'dashboard:import' %}">旧システムデータ取込</a>
                </li>
                <li>
                    <hr class="dropdown-divider">
                </li>
                <li>
                    <a class="dropdown-item text-warning"
                       href="{% url 'dashboard:debug_view' %}">★ デバッグ画面</a>
                </li>
            </ul>
        </li>
    </ul>
    {% if bag_stock_summary %}
        <hr>
        <h6>
            <small>袋在庫サマリー（注文基準）</small>
        </h6>
        <div class="table-responsive small">
            <table class="table table-sm table-bordered">
                <thead class="table-light">
                    <tr>
                        <th>商品</th>
                        <th class="text-center">総数</th>
                        <th class="text-center">未袋</th>
                        <th class="text-center">袋米</th>
                        <th class="text-center">箱入</th>
                        <!-- ▼▼▼ 変更点: 「出荷済」の列ヘッダーを追加 ▼▼▼ -->
                        <th class="text-center">出荷済</th>
                        <!-- ▲▲▲ 変更点ここまで ▲▲▲ -->
                    </tr>
                </thead>
                <tbody>
                    {% for item in bag_stock_summary %}
                        <tr>
                            <td>{{ item.name }}</td>
                            <td class="text-center">{{ item.total }}</td>
                            <td class="text-center text-danger fw-bold">{{ item.unbagged }}</td>
                            <td class="text-center">{{ item.bag_rice }}</td>
                            <td class="text-center">{{ item.boxed }}</td>
                            <!-- ▼▼▼ 変更点: 「出荷済」のデータを表示 ▼▼▼ -->
                            <td class="text-center">{{ item.shipped }}</td>
                            <!-- ▲▲▲ 変更点ここまで ▲▲▲ -->
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
            <div class="text-muted">
                <!-- ▼▼▼ 変更点: 説明文を更新 ▼▼▼ -->
                <small>※「未袋＋袋米＋箱入＋出荷済 = 注文数」。袋米=袋詰済みだが未箱入、箱入=梱包済みだが未出荷、出荷済=発送/手渡し済みの袋数。</small>
                <!-- ▲▲▲ 変更点ここまで ▲▲▲ -->
            </div>
        </div>
    {% endif %}
    <hr>
    <div class="d-flex justify-content-between align-items-center">
        <form action="{% url 'accounts:logout' %}" method="post" class="d-inline">
            {% csrf_token %}
            <button type="submit" class="btn btn-secondary btn-sm">ログアウト</button>
        </form>
        <button type="button"
                class="btn btn-outline-info btn-sm"
                id="manual-open-btn">
            <i class="bi bi-question-circle"></i> マニュアル
        </button>
    </div>
{% endblock %}
```

#### 3. 手順2：バックエンドの実装 (`mg_workflow`アプリケーション)

出荷ワークフロー機能のロジック、API、URL定義を`mg_workflow`アプリケーションとして新規に作成します。

##### **ファイル:** `mg_workflow/api_packaging.py` **(全面的に上書き)**

* 自動引当ボードの全ての非同期操作（状態取得、箱・袋・予約のCRUD、自動提案、ロック制御など）を処理するAPIを実装します。

```python
# mg_workflow/api_packaging.py
from __future__ import annotations
import json
from decimal import Decimal
from typing import Any, Dict, List, Tuple
from collections import defaultdict
from django.conf import settings
from django.db import transaction
from django.db.models import Sum, Count, Q
from django.http import JsonResponse, HttpRequest
from django.shortcuts import get_object_or_404
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_protect
from django.contrib.admin.views.decorators import staff_member_required

from orders.models import Order, OrderItem, Bag, Allocation, Package, PackageItem, PackagePlanItem
from products.models import Product
from accounts.models import Destination

def _json(request: HttpRequest) -> Dict[str, Any]:
    try:
        body = request.body.decode("utf-8") or "{}"
        return json.loads(body)
    except json.JSONDecodeError:
        return {}
def _bad_request(message: str, *, code: str = "invalid_request", extra: Dict[str, Any] | None = None):
    payload = {"ok": False, "error": {"code": code, "message": message}}
    if extra: payload["error"].update(extra)
    return JsonResponse(payload, status=400)
def _ok(data: Dict[str, Any] | None = None, *, status: int = 200):
    payload = {"ok": True}
    if data: payload.update(data)
    return JsonResponse(payload, status=status)
def _pkg_physical_weight(package: Package) -> Decimal:
    box_w = Decimal(str(getattr(settings, "DEFAULT_BOX_WEIGHT_KG", 0.5)))
    bag_w = (Bag.objects.filter(packageitem__package=package).aggregate(total=Sum('product__weight_kg'))["total"] or Decimal("0"))
    return box_w + Decimal(str(bag_w))
def _pkg_weight_with_plans(package: Package) -> Decimal:
    w = _pkg_physical_weight(package)
    for pi in PackagePlanItem.objects.select_related('product').filter(package=package):
        w += Decimal(str(pi.product.weight_kg)) * Decimal(pi.quantity)
    return w
def _assert_pkg_capacity_with_plans_plus(package: Package, extra_weight_kg: Decimal) -> None:
    max_w = Decimal(str(getattr(settings, "PACKAGE_MAX_WEIGHT_KG", 25.0)))
    if _pkg_weight_with_plans(package) + extra_weight_kg > max_w:
        raise ValueError(f"箱重量上限 {max_w}kg（予約含む）を超過します。")
def _ordered_qty(destination_id: int, product_id: int) -> int:
    return int(OrderItem.objects.filter(order__destination_id=destination_id, order__status=Order.OrderStatus.ACCEPTED, product_id=product_id).aggregate(total=Sum('quantity'))["total"] or 0)
def _allocated_qty(destination_id: int, product_id: int) -> int:
    return int(Allocation.objects.filter(order_item__order__destination_id=destination_id, order_item__order__status=Order.OrderStatus.ACCEPTED, order_item__product_id=product_id).count())
def _planned_qty_dest(destination_id: int, product_id: int) -> int:
    return int(PackagePlanItem.objects.filter(package__destination_id=destination_id, product_id=product_id).aggregate(total=Sum('quantity'))["total"] or 0)
def _allocatable_remaining(destination_id: int, product_id: int) -> int:
    ordered = _ordered_qty(destination_id, product_id)
    allocated = _allocated_qty(destination_id, product_id)
    planned = _planned_qty_dest(destination_id, product_id)
    return max(0, ordered - allocated - planned)
def _pick_prepared_bags(product_id: int, count: int) -> List[Bag]:
    return list(Bag.objects.select_for_update(skip_locked=True).filter(prepared=True, product_id=product_id, allocation__isnull=True)[:count])
def _iter_order_items_with_demand(destination_id: int, product_id: int):
    q = (OrderItem.objects.filter(order__destination_id=destination_id, order__status=Order.OrderStatus.ACCEPTED, product_id=product_id).annotate(alloc_count=Count('allocations')).order_by('order_id', 'id').values('id', 'quantity', 'alloc_count'))
    for row in q:
        remaining = int(row['quantity']) - int(row['alloc_count'] or 0)
        if remaining > 0: yield (remaining, row['id'])

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageCreateView(View):
    def post(self, request: HttpRequest):
        data = _json(request)
        destination_id = data.get("destination_id")
        if not destination_id: return _bad_request("destination_id は必須です。")
        destination = get_object_or_404(Destination, pk=destination_id)
        package = Package.objects.create(destination=destination, status=Package.PackageStatus.PACKAGING)
        return _ok({"package": {"id": package.id, "destination_id": destination.id}}, status=201)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageDeleteView(View):
    def delete(self, request: HttpRequest, package_id: int):
        package = get_object_or_404(Package, pk=package_id)
        if package.items.exists(): return _bad_request("箱に袋が入っているため削除できません。先に中身を取り出してください。")
        if package.plan_items.exists(): return _bad_request("箱に予約があるため削除できません。先に予約を0にしてください。")
        package.delete()
        return _ok({"deleted": True}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageItemCreateView(View):
    @transaction.atomic
    def post(self, request: HttpRequest):
        data = _json(request)
        try:
            destination_id = int(data.get("destination_id"))
            product_id = int(data.get("product_id"))
            count = int(data.get("count", 0))
            package_id = int(data.get("package_id"))
        except (TypeError, ValueError):
            return _bad_request("destination_id, product_id, count, package_id は整数で指定してください。")
        if count <= 0: return _bad_request("count は 1 以上で指定してください。")
        package = get_object_or_404(Package, pk=package_id)
        if package.destination_id != destination_id: return _bad_request("package の宛先と destination_id が一致しません。")
        product = get_object_or_404(Product, pk=product_id)
        extra_weight = Decimal(str(product.weight_kg)) * Decimal(count)
        try:
            _assert_pkg_capacity_with_plans_plus(package, extra_weight)
        except ValueError as e:
            return _bad_request(str(e), code="over_weight")
        created_items = []
        bags_to_process = count
        unpacked_bags = Bag.objects.select_for_update(skip_locked=True).filter(
            prepared=True,
            product_id=product_id,
            allocation__order_item__order__destination_id=destination_id,
            packageitem__isnull=True
        )[:bags_to_process]
        for bag in unpacked_bags:
            pi = PackageItem.objects.create(package=package, bag=bag)
            created_items.append({"package_item_id": pi.id, "bag_id": bag.id, "product_name": product.name})
        bags_to_process -= len(unpacked_bags)
        if bags_to_process > 0:
            remaining_demand = _allocatable_remaining(destination_id, product_id)
            if bags_to_process > remaining_demand:
                return _bad_request("宛先合計の注文枠（予約含む）を超えています。", extra={"remaining": remaining_demand, "requested": bags_to_process})
            new_bags = _pick_prepared_bags(product_id, bags_to_process)
            if len(new_bags) < bags_to_process:
                return _bad_request("準備済み（未引当）の袋が不足しています。", extra={"available": len(new_bags)})
            demand_iter = _iter_order_items_with_demand(destination_id, product_id)
            alloc_targets: List[int] = []
            for remaining_needed, order_item_id in demand_iter:
                take = min(remaining_needed, bags_to_process - len(alloc_targets))
                alloc_targets.extend([order_item_id] * take)
                if len(alloc_targets) >= bags_to_process: break
            if len(alloc_targets) < bags_to_process:
                return _bad_request("割当先の注文明細が不足しています。")
            for bag, order_item_id in zip(new_bags, alloc_targets):
                Allocation.objects.create(order_item_id=order_item_id, bag=bag)
                pi = PackageItem.objects.create(package=package, bag=bag)
                created_items.append({"package_item_id": pi.id, "bag_id": bag.id, "product_name": product.name})
        return _ok({"created": created_items}, status=201)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageItemDeleteView(View):
    @transaction.atomic
    def delete(self, request: HttpRequest, package_item_id: int):
        pi = get_object_or_404(PackageItem.objects.select_related('package', 'bag'), pk=package_item_id)
        if hasattr(pi.bag, 'allocation'):
            pi.bag.allocation.delete()
        pi.delete()
        return _ok({"deleted": True}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageItemMoveView(View):
    @transaction.atomic
    def patch(self, request: HttpRequest, package_item_id: int):
        data = _json(request)
        try: to_package_id = int(data.get("to_package_id"))
        except (TypeError, ValueError): return _bad_request("to_package_id は整数で指定してください。")
        pi = get_object_or_404(PackageItem.objects.select_related('package'), pk=package_item_id)
        src_pkg, dst_pkg = pi.package, get_object_or_404(Package, pk=to_package_id)
        
        if src_pkg.destination_id != dst_pkg.destination_id: return _bad_request("移動元と移動先の宛先が一致しません。")
        bag_w = Decimal(str(pi.bag.product.weight_kg))
        try: _assert_pkg_capacity_with_plans_plus(dst_pkg, bag_w)
        except ValueError as e: return _bad_request(str(e), code="over_weight")
        pi.package = dst_pkg
        pi.save(update_fields=["package"])
        return _ok({"moved": True, "package_item_id": pi.id, "to_package_id": dst_pkg.id}, status=200)

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class BoardStateView(View):
    def get(self, request: HttpRequest):
        prepared_qs = (Bag.objects.filter(prepared=True, packageitem__isnull=True).values('product_id', 'product__name', 'product__weight_kg').annotate(qty=Count('id')).order_by('product__name'))
        prepared_groups = [{"product_id": r["product_id"], "product_name": r["product__name"], "weight_kg": float(r["product__weight_kg"]), "qty": int(r["qty"])} for r in prepared_qs]
        dest_ids = set(Destination.objects.filter(Q(order__status=Order.OrderStatus.ACCEPTED) | Q(package__isnull=False)).values_list('id', flat=True))
        
        ordered_map: Dict[Tuple[int,int], int] = {}
        for row in (OrderItem.objects.filter(order__status=Order.OrderStatus.ACCEPTED).values('order__destination_id', 'product_id').annotate(q=Sum('quantity'))):
            ordered_map[(row['order__destination_id'], row['product_id'])] = int(row['q'] or 0)
        
        allocated_map: Dict[Tuple[int,int], int] = {}
        for row in (Allocation.objects.filter(order_item__order__status=Order.OrderStatus.ACCEPTED).values('order_item__order__destination_id', 'order_item__product_id').annotate(c=Count('id'))):
            key = (row['order_item__order__destination_id'], row['order_item__product_id'])
            allocated_map[key] = int(row['c'] or 0)

        placeholders_by_dest = defaultdict(list)
        for (dest_id, product_id), q in ordered_map.items():
            alloc = allocated_map.get((dest_id, product_id), 0)
            remaining = max(0, q - alloc)
            if remaining > 0:
                product = Product.objects.get(pk=product_id)
                placeholders_by_dest[dest_id].append({"product_id": product_id, "product_name": product.name, "weight_kg": float(product.weight_kg), "remaining": remaining})

        destinations_out: List[Dict[str, Any]] = []
        max_weight = Decimal(str(getattr(settings, "PACKAGE_MAX_WEIGHT_KG", 25.0)))
        for did in sorted(dest_ids):
            dest = Destination.objects.get(pk=did)
            packages = []
            pkg_qs = Package.objects.filter(destination_id=did).order_by('id')
            
            for pkg in pkg_qs:
                items = []
                for pi in PackageItem.objects.select_related('bag__product').filter(package=pkg).order_by('id'):
                    items.append({"package_item_id": pi.id, "bag_id": pi.bag.id, "product_id": pi.bag.product.id, "product_name": pi.bag.product.name, "weight_kg": float(pi.bag.product.weight_kg)})
                plans = []
                for pl in PackagePlanItem.objects.select_related('product').filter(package=pkg).order_by('id'):
                    plans.append({"plan_item_id": pl.id, "product_id": pl.product_id, "product_name": pl.product.name, "weight_kg": float(pl.product.weight_kg), "quantity": int(pl.quantity)})
                current_weight = _pkg_weight_with_plans(pkg)
                packages.append({
                    "id": pkg.id,
                    "label": getattr(pkg, "label", None),
                    "lock_status": pkg.lock_status,
                    "status": pkg.status,
                    "items": items,
                    "plans": plans,
                    "current_weight_kg": float(current_weight),
                    "max_weight_kg": float(max_weight),
                })
            
            destinations_out.append({
                "id": dest.id, 
                "name": dest.name, 
                "packages": packages,
                "unallocated_items": sorted(placeholders_by_dest.get(dest.id, []), key=lambda x: x['product_name'])
            })
            
        return _ok({"prepared_groups": prepared_groups, "destinations": destinations_out}, status=200)

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PreparedBagsView(View):
    def get(self, request: HttpRequest):
        prepared_qs = (Bag.objects.filter(prepared=True, allocation__isnull=True).values('product_id', 'product__name', 'product__weight_kg').annotate(qty=Count('id')).order_by('product__name'))
        prepared_groups = [{"product_id": r["product_id"], "product_name": r["product__name"], "weight_kg": float(r["product__weight_kg"]), "qty": int(r["qty"])} for r in prepared_qs]
        return _ok({"prepared_groups": prepared_groups}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PlanItemUpsertView(View):
    @transaction.atomic
    def post(self, request: HttpRequest):
        data = _json(request)
        try:
            package_id = int(data.get("package_id"))
            product_id = int(data.get("product_id"))
            quantity = int(data.get("quantity"))
        except (TypeError, ValueError): return _bad_request("package_id, product_id, quantity は整数で指定してください。")
        if quantity < 0: return _bad_request("quantity は 0 以上で指定してください。")
        package = get_object_or_404(Package, pk=package_id)
        product = get_object_or_404(Product, pk=product_id)
        ordered, allocated, planned_total = _ordered_qty(package.destination_id, product_id), _allocated_qty(package.destination_id, product_id), _planned_qty_dest(package.destination_id, product_id)
        cur = PackagePlanItem.objects.filter(package=package, product=product).first()
        current_qty = cur.quantity if cur else 0
        delta = quantity - current_qty
        if allocated + planned_total + delta > ordered:
            return _bad_request("宛先合計の注文枠（予約含む）を超えています。", extra={"ordered": ordered, "allocated": allocated, "planned_total": planned_total, "delta": delta})
        delta_w = Decimal(str(product.weight_kg)) * Decimal(delta if delta > 0 else 0)
        try: _assert_pkg_capacity_with_plans_plus(package, delta_w)
        except ValueError as e: return _bad_request(str(e), code="over_weight")
        if quantity == 0:
            if cur: cur.delete()
            return _ok({"upsert": {"deleted": True}}, status=200)
        else:
            if cur:
                cur.quantity = quantity
                cur.save(update_fields=["quantity", "updated_at"])
                obj = cur
            else:
                obj = PackagePlanItem.objects.create(package=package, product=product, quantity=quantity)
            return _ok({"upsert": {"plan_item_id": obj.id, "package_id": package.id, "product_id": product.id, "product_name": product.name, "quantity": obj.quantity}}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PlanItemConsumeView(View):
    @transaction.atomic
    def post(self, request: HttpRequest):
        data = _json(request)
        try:
            package_id = int(data.get("package_id"))
            product_id = int(data.get("product_id"))
            count = int(data.get("count"))
        except (TypeError, ValueError): return _bad_request("package_id, product_id, count は整数で指定してください。")
        if count <= 0: return _bad_request("count は 1 以上で指定してください。")
        package = get_object_or_404(Package, pk=package_id)
        product = get_object_or_404(Product, pk=product_id)
        plan = PackagePlanItem.objects.filter(package=package, product=product).first()
        if not plan or plan.quantity < count: return _bad_request("予約数量が不足しています。")
        bags = _pick_prepared_bags(product_id, count)
        if len(bags) < count: return _bad_request("準備済み（未引当）の袋が不足しています。", extra={"available": len(bags)})
        demand_iter = _iter_order_items_with_demand(package.destination_id, product_id)
        alloc_targets: List[int] = []
        for remaining_needed, order_item_id in demand_iter:
            take = min(remaining_needed, count - len(alloc_targets))
            alloc_targets.extend([order_item_id] * take)
            if len(alloc_targets) >= count: break
        if len(alloc_targets) < count: return _bad_request("割当先の注文明細が不足しています。")
        created_items = []
        for bag, order_item_id in zip(bags, alloc_targets):
            alloc = Allocation.objects.create(order_item_id=order_item_id, bag=bag)
            pi = PackageItem.objects.create(package=package, bag=bag)
            created_items.append({"package_item_id": pi.id, "bag_id": bag.id, "allocation_id": alloc.id, "product_name": product.name})
        plan.quantity -= count
        if plan.quantity <= 0:
            plan.delete()
            remaining = 0
        else:
            plan.save(update_fields=["quantity", "updated_at"])
            remaining = plan.quantity
        return _ok({"consumed": created_items, "remaining_plan_qty": remaining}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageLabelUpdateView(View):
    def patch(self, request: HttpRequest, package_id: int):
        data = _json(request)
        if "label" not in data: return _bad_request("label は必須です。")
        label = (data.get("label") or "").strip()
        pkg = get_object_or_404(Package, pk=package_id)
        if len(label) > 50: return _bad_request("label は50文字以内で指定してください。", code="too_long")
        pkg.label = label if label else None
        pkg.save(update_fields=["label", "updated_at"])
        return _ok({"package": {"id": pkg.id, "label": pkg.label}}, status=200)

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class PackageLockStatusUpdateView(View):
    def patch(self, request: HttpRequest, package_id: int):
        data = _json(request)
        lock_status = data.get("lock_status")
        valid_statuses = [s for s in Package.LockStatus.choices]
        if lock_status not in valid_statuses:
            return _bad_request(f"lock_status は {', '.join(valid_statuses)} のいずれかで指定してください。", code="invalid_lock_status")
        pkg = get_object_or_404(Package, pk=package_id)
        pkg.lock_status = lock_status
        pkg.save(update_fields=["lock_status", "updated_at"])
        return _ok({"package": {"id": pkg.id, "lock_status": pkg.lock_status}}, status=200)

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class SidebarStockSummaryView(View):
    def get(self, request: HttpRequest):
        required_qs = (
            OrderItem.objects
            .filter(order__status=Order.OrderStatus.ACCEPTED)
            .values('product_id', 'product__name')
            .annotate(total_ordered=Sum('quantity'))
            .order_by('product__name')
        )
        summary_map = {
            r['product_id']: {
                'name': r['product__name'],
                'total_ordered': r['total_ordered'] or 0,
                'prepared_total': 0,
                'bagged_unpacked': 0,
                'bagged_packed': 0
            } for r in required_qs
        }
        prepared_bags_qs = (
            Bag.objects
            .filter(prepared=True)
            .values('product_id')
            .annotate(
                total_prepared_count=Count('id'),
                total_packed_count=Count('packageitem', filter=Q(packageitem__isnull=False))
            )
        )
        for row in prepared_bags_qs:
            pid = row['product_id']
            if pid in summary_map:
                total_prepared = row['total_prepared_count'] or 0
                total_packed = row['total_packed_count'] or 0
                summary_map[pid]['prepared_total'] = total_prepared
                summary_map[pid]['bagged_packed'] = total_packed
                summary_map[pid]['bagged_unpacked'] = total_prepared - total_packed
        
        summary_list = []
        for pid, data in summary_map.items():
            total_ordered = data['total_ordered']
            prepared_total = data['prepared_total']
            unbagged_count = max(0, total_ordered - prepared_total)
            summary_list.append({
                'name': data['name'],
                'total': total_ordered,
                'unbagged': unbagged_count,
                'bag_rice': data['bagged_unpacked'],
                'boxed': data['bagged_packed']
            })
        return JsonResponse({"bag_stock_summary": summary_list})

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class AllocatableItemsView(View):
    def get(self, request: HttpRequest):
        try:
            destination_id = int(request.GET.get("destination_id"))
        except (TypeError, ValueError):
            return _bad_request("destination_id は必須のクエリパラメータです。")
        demand_map = {}
        ordered_items = OrderItem.objects.filter(order__destination_id=destination_id, order__status=Order.OrderStatus.ACCEPTED).values('product_id', 'product__name', 'product__weight_kg').annotate(qty=Sum('quantity'))
        for item in ordered_items:
            demand_map[item['product_id']] = {"product_id": item['product_id'], "product_name": item['product__name'], "weight_kg": float(item['product__weight_kg']), "ordered": item['qty'] or 0, "allocated": 0, "planned": 0}
        allocated_items = Allocation.objects.filter(order_item__order__destination_id=destination_id).values('order_item__product_id').annotate(qty=Count('id'))
        for item in allocated_items:
            pid = item['order_item__product_id']
            if pid in demand_map:
                demand_map[pid]['allocated'] = item['qty'] or 0
        planned_items = PackagePlanItem.objects.filter(package__destination_id=destination_id).values('product_id').annotate(qty=Sum('quantity'))
        for item in planned_items:
            pid = item['product_id']
            if pid in demand_map:
                demand_map[pid]['planned'] = int(item['qty'] or 0)
        stock_map = {}
        prepared_bags = Bag.objects.filter(prepared=True, allocation__isnull=True).values('product_id').annotate(qty=Count('id'))
        for bag in prepared_bags:
            stock_map[bag['product_id']] = bag['qty'] or 0
        result = []
        for pid, data in demand_map.items():
            remaining_demand = data['ordered'] - (data['allocated'] + data['planned'])
            if remaining_demand > 0:
                available_stock = stock_map.get(pid, 0)
                result.append({"product_id": pid, "product_name": data['product_name'], "weight_kg": data['weight_kg'], "remaining_demand": remaining_demand, "available_stock": available_stock})
        result.sort(key=lambda x: x['product_name'])
        return _ok({"allocatable_items": result})

def _pack_bags(bags, max_weight, box_weight, existing_packages=None):
    sorted_bags = sorted(bags, key=lambda b: Decimal(str(b.product.weight_kg)), reverse=True)
    packages = []
    if existing_packages:
        packages = existing_packages
    for bag in sorted_bags:
        bag_weight = Decimal(str(bag.product.weight_kg))
        bag_variety_id = bag.product.variety_id
        target_box = None
        box_for_same_variety = None
        for pkg in packages:
            if bag_variety_id in pkg['variety_ids'] and pkg['weight'] + bag_weight <= max_weight:
                box_for_same_variety = pkg
                break
        if box_for_same_variety:
            target_box = box_for_same_variety
        else:
            box_for_any = None
            for pkg in packages:
                if pkg['weight'] + bag_weight <= max_weight:
                    box_for_any = pkg
                    break
            if box_for_any:
                target_box = box_for_any
        if target_box:
            target_box['bags'].append(bag)
            target_box['weight'] += bag_weight
            target_box['variety_ids'].add(bag_variety_id)
        else:
            packages.append({'id': None, 'bags': [bag], 'weight': box_weight + bag_weight, 'variety_ids': {bag_variety_id}})
    return packages

def _get_repack_assets(destination: Destination) -> Tuple[List[Package], List[Dict], List[Bag]]:
    untouchable_bag_ids = set()
    append_only_packages_for_algo = []
    
    existing_packages_qs = Package.objects.prefetch_related('items__bag__product__variety').filter(destination=destination)
    
    for pkg in existing_packages_qs:
        is_fixed = pkg.lock_status == Package.LockStatus.LOCKED or pkg.status != Package.PackageStatus.PACKAGING
        if is_fixed:
            untouchable_bag_ids.update(item.bag_id for item in pkg.items.all())
        elif pkg.lock_status == Package.LockStatus.APPEND_ONLY and pkg.status == Package.PackageStatus.PACKAGING:
            current_bags = list(item.bag for item in pkg.items.all())
            untouchable_bag_ids.update(b.id for b in current_bags)
            append_only_packages_for_algo.append({'id': pkg.id, 'bags': current_bags, 'weight': _pkg_weight_with_plans(pkg), 'variety_ids': {b.product.variety_id for b in current_bags}, 'initial_bag_ids': {b.id for b in current_bags}})

    demand_map = {item['product_id']: item['total_ordered'] for item in OrderItem.objects.filter(order__destination=destination, order__status=Order.OrderStatus.ACCEPTED).values('product_id').annotate(total_ordered=Sum('quantity'))}
    allocated_counts = {pid: count for pid, count in Allocation.objects.filter(order_item__order__destination=destination).values_list('order_item__product_id').annotate(c=Count('id'))}
    
    all_destination_bags = []
    all_destination_bags.extend(list(Bag.objects.filter(allocation__order_item__order__destination=destination)))
    
    for product_id, total_ordered in demand_map.items():
        needed = total_ordered - allocated_counts.get(product_id, 0)
        if needed > 0:
            unallocated = Bag.objects.filter(prepared=True, allocation__isnull=True, product_id=product_id)[:needed]
            all_destination_bags.extend(unallocated)

    movable_bags = [b for b in all_destination_bags if b.id not in untouchable_bag_ids]
    
    return [], append_only_packages_for_algo, movable_bags

@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class ProposePackingView(View):
    def get(self, request: HttpRequest):
        try:
            destination_id = int(request.GET.get("destination_id"))
        except (TypeError, ValueError):
            return _bad_request("destination_id は必須のクエリパラメータです。")
        destination = get_object_or_404(Destination, pk=destination_id)
        locked_packages, append_only_packages, movable_bags = _get_repack_assets(destination)
        max_weight = Decimal(str(getattr(settings, "PACKAGE_MAX_WEIGHT_KG", 25.0)))
        box_weight = Decimal(str(getattr(settings, "DEFAULT_BOX_WEIGHT_KG", 0.5)))
        calculated_packages = _pack_bags(movable_bags, max_weight, box_weight, existing_packages=append_only_packages)
        proposal_out = []
        
        fixed_packages_qs = Package.objects.prefetch_related('items__bag__product').filter(destination=destination).exclude(
            lock_status=Package.LockStatus.UNLOCKED, status=Package.PackageStatus.PACKAGING
        )
        for pkg in fixed_packages_qs:
            note = f"箱#{pkg.id} 維持"
            if pkg.lock_status == Package.LockStatus.LOCKED:
                note += " (ロック中)"
            elif pkg.status != Package.PackageStatus.PACKAGING:
                note += f" ({pkg.get_status_display()})"
            
            items = sorted([{"bag_id": i.bag.id, "product_name": i.bag.product.name, "weight_kg": float(i.bag.product.weight_kg)} for i in pkg.items.all()], key=lambda x: x['product_name'])
            proposal_out.append({"note": note, "total_weight_kg": float(_pkg_weight_with_plans(pkg)), "items": items})
        
        new_box_counter = 0
        for pkg_group in calculated_packages:
            note = ""
            if pkg_group.get('id') is None:
                new_box_counter += 1
                note = f"新規作成 {new_box_counter}"
            else:
                new_bags_count = len({b.id for b in pkg_group['bags']} - pkg_group['initial_bag_ids'])
                note = f"箱#{pkg_group['id']} " + ("に追加" if new_bags_count > 0 else "は維持")
            items = sorted([{"bag_id": b.id, "product_name": b.product.name, "weight_kg": float(b.product.weight_kg)} for b in pkg_group['bags']], key=lambda x: x['product_name'])
            proposal_out.append({"note": note, "total_weight_kg": float(pkg_group['weight']), "items": items})
        if not proposal_out:
            return _ok({"proposal": [], "message": "再梱包の対象となる袋がありません。"})
        return _ok({"proposal": sorted(proposal_out, key=lambda p: p['note'])})

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class ApplyPackingProposalView(View):
    @transaction.atomic
    def post(self, request: HttpRequest):
        data = _json(request)
        try:
            destination_id = int(data.get("destination_id"))
        except (TypeError, ValueError):
            return _bad_request("destination_id は整数で指定してください。")
        destination = get_object_or_404(Destination, pk=destination_id)
        _, append_only_packages, movable_bags = _get_repack_assets(destination)
        
        Package.objects.filter(
            destination=destination,
            lock_status=Package.LockStatus.UNLOCKED,
            status=Package.PackageStatus.PACKAGING
        ).delete()

        movable_bag_ids = {b.id for b in movable_bags}
        if movable_bag_ids:
            Allocation.objects.filter(bag_id__in=movable_bag_ids).delete()
        max_weight = Decimal(str(getattr(settings, "PACKAGE_MAX_WEIGHT_KG", 25.0)))
        box_weight = Decimal(str(getattr(settings, "DEFAULT_BOX_WEIGHT_KG", 0.5)))
        final_package_groups = _pack_bags(movable_bags, max_weight, box_weight, existing_packages=append_only_packages)
        created_count, updated_count = 0, 0
        for pkg_group in final_package_groups:
            if not pkg_group['bags']: continue
            for bag in pkg_group['bags']:
                if bag.id in movable_bag_ids:
                    demand_iter = _iter_order_items_with_demand(destination.id, bag.product_id)
                    try:
                        _, order_item_id = next(demand_iter)
                        Allocation.objects.create(order_item_id=order_item_id, bag=bag)
                    except StopIteration:
                        return _bad_request(f"商品「{bag.product.name}」の割当先注文が見つかりませんでした。")
            if pkg_group.get('id') is None:
                package = Package.objects.create(destination=destination, status=Package.PackageStatus.PACKAGING)
                PackageItem.objects.bulk_create([PackageItem(package=package, bag=bag) for bag in pkg_group['bags']])
                created_count += 1
            else:
                package = Package.objects.get(id=pkg_group['id'])
                new_bags = [b for b in pkg_group['bags'] if b.id not in pkg_group['initial_bag_ids']]
                if new_bags:
                    PackageItem.objects.bulk_create([PackageItem(package=package, bag=bag) for bag in new_bags])
                updated_count += 1
        return _ok({"message": "梱包を適用しました。", "packages_created": created_count, "packages_updated": updated_count})

def _get_global_repack_assets() -> Tuple[List[Dict], List[Bag], set[int]]:
    append_only_packages_for_algo = []
    untouchable_bag_ids = set()
    fixed_packages_qs = Package.objects.prefetch_related('items__bag__product__variety').filter(
        Q(lock_status__in=[Package.LockStatus.LOCKED, Package.LockStatus.APPEND_ONLY]) |
        Q(status__in=[
            Package.PackageStatus.READY_TO_SHIP,
            Package.PackageStatus.LABEL_PRINTED,
            Package.PackageStatus.SHIPPED,
            Package.PackageStatus.DELIVERED,
        ])
    )

    for pkg in fixed_packages_qs:
        current_bags = list(item.bag for item in pkg.items.all())
        untouchable_bag_ids.update(b.id for b in current_bags)
        if pkg.lock_status == Package.LockStatus.APPEND_ONLY and pkg.status == Package.PackageStatus.PACKAGING:
            append_only_packages_for_algo.append({'id': pkg.id, 'bags': current_bags, 'weight': _pkg_weight_with_plans(pkg), 'variety_ids': {b.product.variety_id for b in current_bags}, 'initial_bag_ids': {b.id for b in current_bags}, 'destination_id': pkg.destination_id})
    
    movable_bags = list(Bag.objects.select_related('product__variety').filter(prepared=True).exclude(id__in=untouchable_bag_ids))
    movable_bag_ids = {b.id for b in movable_bags}
    return append_only_packages_for_algo, movable_bags, movable_bag_ids

def _pack_bags_globally(bags_with_dest: List[Bag], max_weight: Decimal, box_weight: Decimal, existing_packages: List[Dict]) -> Dict[int, List[Dict]]:
    bags_by_destination = defaultdict(list)
    for bag in bags_with_dest:
        dest_id = getattr(bag, 'temp_destination_id', None)
        if dest_id:
            bags_by_destination[dest_id].append(bag)
    existing_packages_by_destination = defaultdict(list)
    for pkg in existing_packages:
        existing_packages_by_destination[pkg['destination_id']].append(pkg)
    final_packages_by_destination = {}
    all_destination_ids = set(bags_by_destination.keys()) | set(existing_packages_by_destination.keys())
    for dest_id in all_destination_ids:
        dest_bags = sorted(bags_by_destination.get(dest_id, []), key=lambda b: b.id)
        dest_existing_pkgs = existing_packages_by_destination.get(dest_id, [])
        packed = _pack_bags(dest_bags, max_weight, box_weight, existing_packages=dest_existing_pkgs)
        if packed:
            final_packages_by_destination[dest_id] = packed
    return final_packages_by_destination

def _calculate_global_proposal(simulated: bool = True):
    with transaction.atomic():
        append_only_packages, movable_bags, movable_bag_ids = _get_global_repack_assets()
        total_demand_map = defaultdict(int)
        q_total_demand = (OrderItem.objects.filter(order__status=Order.OrderStatus.ACCEPTED).values('order__destination_id', 'product_id').annotate(total_qty=Sum('quantity')))
        for row in q_total_demand:
            key = (row['order__destination_id'], row['product_id'])
            total_demand_map[key] = row['total_qty']
        
        satisfied_by_fixed_map = defaultdict(int)
        fixed_bags_qs = Bag.objects.filter(
            packageitem__package__isnull=False
        ).filter(
            Q(packageitem__package__lock_status__in=[Package.LockStatus.LOCKED, Package.LockStatus.APPEND_ONLY]) |
            Q(packageitem__package__status__in=[
                Package.PackageStatus.READY_TO_SHIP,
                Package.PackageStatus.LABEL_PRINTED,
                Package.PackageStatus.SHIPPED,
                Package.PackageStatus.DELIVERED,
            ])
        ).select_related('product', 'packageitem__package__destination')
        
        for bag in fixed_bags_qs:
            if hasattr(bag, 'packageitem') and bag.packageitem:
                key = (bag.packageitem.package.destination_id, bag.product_id)
                satisfied_by_fixed_map[key] += 1
        
        net_demand_map = defaultdict(int)
        for key, total_qty in total_demand_map.items():
            net_qty = total_qty - satisfied_by_fixed_map.get(key, 0)
            if net_qty > 0:
                net_demand_map[key] = net_qty
        
        flat_demand = []
        for (dest_id, prod_id), count in sorted(net_demand_map.items()):
            flat_demand.extend([(prod_id, dest_id)] * count)
        bags_by_product = defaultdict(list)
        for bag in sorted(movable_bags, key=lambda b: b.id):
            bags_by_product[bag.product_id].append(bag)
        bags_with_dest = []
        for prod_id, dest_id in flat_demand:
            if bags_by_product.get(prod_id):
                bag = bags_by_product[prod_id].pop(0)
                bag.temp_destination_id = dest_id
                bags_with_dest.append(bag)
        max_weight = Decimal(str(getattr(settings, "PACKAGE_MAX_WEIGHT_KG", 25.0)))
        box_weight = Decimal(str(getattr(settings, "DEFAULT_BOX_WEIGHT_KG", 0.5)))
        final_package_groups_by_dest = _pack_bags_globally(bags_with_dest, max_weight, box_weight, append_only_packages)
        if simulated:
            transaction.set_rollback(True)
            return final_package_groups_by_dest, movable_bag_ids
        
        Package.objects.filter(
            lock_status=Package.LockStatus.UNLOCKED,
            status=Package.PackageStatus.PACKAGING
        ).delete()

        if movable_bag_ids:
            Allocation.objects.filter(bag_id__in=movable_bag_ids).delete()
        order_item_q = (OrderItem.objects.filter(order__status=Order.OrderStatus.ACCEPTED).annotate(alloc_count=Count('allocations')).order_by('order__created_at', 'id'))
        order_item_pool = defaultdict(list)
        for item in order_item_q:
            remaining = item.quantity - item.alloc_count
            if remaining > 0:
                key = (item.order.destination_id, item.product_id)
                order_item_pool[key].extend([item.id] * remaining)
        created_count, updated_count = 0, 0
        for dest_id, pkg_groups in final_package_groups_by_dest.items():
            destination = get_object_or_404(Destination, pk=dest_id)
            for pkg_group in pkg_groups:
                if not pkg_group['bags']: continue
                for bag in pkg_group['bags']:
                    if bag.id in movable_bag_ids:
                        try:
                            key = (dest_id, bag.product_id)
                            order_item_id = order_item_pool[key].pop(0)
                            Allocation.objects.create(order_item_id=order_item_id, bag=bag)
                        except (KeyError, IndexError):
                            raise ValueError(f"商品「{bag.product.name}」の割当先注文(宛先:{dest_id})が見つかりませんでした。")
                if pkg_group.get('id') is None:
                    package = Package.objects.create(destination=destination, status=Package.PackageStatus.PACKAGING)
                    PackageItem.objects.bulk_create([PackageItem(package=package, bag=bag) for bag in pkg_group['bags']])
                    created_count += 1
                else:
                    package = get_object_or_404(Package, id=pkg_group['id'])
                    new_bags = [b for b in pkg_group['bags'] if b.id not in pkg_group['initial_bag_ids']]
                    if new_bags:
                        PackageItem.objects.bulk_create([PackageItem(package=package, bag=bag) for bag in new_bags])
                    updated_count += 1
        return created_count, updated_count
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class ProposeGlobalPackingView(View):
    def get(self, request: HttpRequest):
        try:
            final_package_groups_by_dest, _ = _calculate_global_proposal(simulated=True)
        except Exception as e:
            return _bad_request(f"提案の作成中にエラーが発生しました: {e}", code="calculation_error")
        proposal_by_dest_out = {}
        dest_cache = {d.id: d for d in Destination.objects.filter(id__in=final_package_groups_by_dest.keys())}
        for dest_id, calculated_packages in final_package_groups_by_dest.items():
            destination = dest_cache.get(dest_id)
            if not destination: continue
            locked_packages = Package.objects.filter(destination=destination, lock_status=Package.LockStatus.LOCKED)
            proposal_out = []
            for pkg in locked_packages:
                items = sorted([{"bag_id": i.bag.id, "product_name": i.bag.product.name, "weight_kg": float(i.bag.product.weight_kg)} for i in pkg.items.all()], key=lambda x: x['product_name'])
                proposal_out.append({"note": f"箱#{pkg.id} 維持 (ロック中)", "total_weight_kg": float(_pkg_weight_with_plans(pkg)), "items": items})
            new_box_counter = 0
            for pkg_group in calculated_packages:
                note = ""
                if pkg_group.get('id') is None:
                    new_box_counter += 1
                    note = f"新規作成 {new_box_counter}"
                else:
                    new_bags_count = len({b.id for b in pkg_group['bags']} - pkg_group.get('initial_bag_ids', set()))
                    note = f"箱#{pkg_group['id']} " + ("に追加" if new_bags_count > 0 else "は維持")
                items = sorted([{"bag_id": b.id, "product_name": b.product.name, "weight_kg": float(b.product.weight_kg)} for b in pkg_group['bags']], key=lambda x: x['product_name'])
                proposal_out.append({"note": note, "total_weight_kg": float(pkg_group['weight']), "items": items})
            if proposal_out:
                proposal_by_dest_out[str(dest_id)] = {"destination_name": destination.name, "proposal": proposal_out}
        if not proposal_by_dest_out:
            return _ok({"proposal_by_destination": {}, "message": "再梱包の対象となる袋がありません。"})
        return _ok({"proposal_by_destination": proposal_by_dest_out})

@method_decorator(csrf_protect, name="dispatch")
@method_decorator(staff_member_required(login_url='/accounts/login/'), name="dispatch")
class ApplyGlobalPackingProposalView(View):
    def post(self, request: HttpRequest):
        try:
            created_count, updated_count = _calculate_global_proposal(simulated=False)
            return _ok({"message": "一括梱包を適用しました。", "packages_created": created_count, "packages_updated": updated_count})
        except ValueError as e:
            return _bad_request(str(e), code="application_error")
        except Exception as e:
            return _bad_request(f"適用中に予期せぬエラーが発生しました: {e}", code="internal_error")
